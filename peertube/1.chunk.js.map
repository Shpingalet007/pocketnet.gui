{"version":3,"sources":["webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/loader-interface.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/stringly-typed-event-emitter.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/http-media-manager.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/media-peer.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/p2p-media-manager.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/bandwidth-approximator.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/segments-memory-storage.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-core/lib/hybrid-loader.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/byte-range.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/segment-manager.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/hlsjs-loader.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/engine.ts","webpack:///./src/assets/player/p2p-media-loader/core/p2p-media-loader-master/p2p-media-loader-hlsjs/lib/index.ts"],"names":["Events","on","event","listener","super","emit","args","settings","fetchRequests","Map","failedSegments","debug","fetch","download","segment","downloadedPieces","this","isDownloading","cleanTimedOutFailedSegments","segmentUrl","buildSegmentUrl","fetchAbort","AbortController","set","id","initialPriority","priority","requestUrl","headers","Headers","range","append","undefined","httpUseRanges","bytesDownloaded","piece","byteLength","signal","fetchRequest","setupFetchEvents","catch","err","name","message","fetchError","Error","segmentFailure","url","netError","request","updatePriority","get","requiredSegmentsPriority","abort","delete","has","isFailed","time","now","getActiveDownloads","getActiveDownloadsCount","size","destroy","forEach","clear","fetchResponse","dataReader","body","getReader","contentLengthStr","contentLength","Number","parseFloat","dataBytes","Uint8Array","read","nextChunkPos","Array","isArray","status","pieceBytes","done","chunkBytes","value","length","segmentDownloadFinished","buffer","data","responseUrl","segmentValidator","error","httpFailedSegmentTimeout","candidates","push","performance","localTransport","segmentUrlBuilder","MediaPeerCommands","MediaPeerSegmentStatus","DownloadingSegment","pieces","peer","remoteAddress","downloadingSegmentId","downloadingSegment","segmentsMap","timer","onPeerConnect","onPeerClose","terminateSegmentRequest","onPeerError","receiveSegmentPiece","segmentId","segmentData","offset","getJsonCommand","bytes","JSON","parse","TextDecoder","decode","onPeerData","command","c","SegmentsMap","createSegmentsMap","m","SegmentRequest","i","SegmentData","s","cancelResponseTimeoutTimer","SegmentAbsent","CancelSegmentRequest","segments","Object","streamSwarmId","keys","swarmData","segmentsIds","split","segmentsStatuses","segmentStatus","sendCommand","write","stringify","getDownloadingSegmentId","getSegmentsMap","sendSegmentsMap","sendSegmentData","bytesLeft","bytesToSend","webRtcMaxMessageSize","from","sendSegmentAbsent","requestSegment","runResponseTimeoutTimer","cancelSegmentRequest","setTimeout","p2pSegmentDownloadTimeout","clearTimeout","PEER_ID_VERSION_PREFIX","replace","v","parseInt","slice","PeerSegmentRequest","peerId","segmentsStorage","trackerClient","peers","peerCandidates","peerSegmentRequests","pendingTrackerClient","getPeers","getPeerId","toString","setStreamSwarmId","masterSwarmId","isDestroyed","infoHash","update","digest","createClient","useP2P","clientOptions","announce","trackerAnnounce","rtcConfig","port","getAnnounceOpts","numwant","peerRequestsPerAnnounce","oldTrackerClient","onTrackerError","onTrackerWarning","onTrackerUpdate","onTrackerPeer","start","warning","trackerPeer","onPeerDataUpdated","onSegmentRequest","onSegmentLoaded","onSegmentAbsent","onSegmentError","onSegmentSize","onSegmentStartLoad","onSegmentTimeout","onPieceBytesDownloaded","onPieceBytesUploaded","peerCandidatesById","values","Loaded","Math","floor","random","peerSegmentRequest","swarmChange","stop","removeAllListeners","peerCandidateById","peerCandidate","sendSegmentsMapToAll","getOverallSegmentsMap","overallSegmentsMap","LoadingByHttp","index","indexOf","splice","key","getSegment","description","PEER_ID_SYMBOLS","charAt","TextEncoder","encode","generatePeerId","ArrayBuffer","enabled","SMOOTH_INTERVAL","NumberWithTime","timeStamp","BandwidthApproximator","lastBytes","currentBytesSum","lastBandwidth","addBytes","shift","interval","min","getBandwidth","maxBandwidth","bandwidth","getSmoothInterval","getMeasureInterval","cache","storeSegment","lastAccessed","cacheItem","hasSegment","clean","lockedSegmentsFilter","segmentsToDelete","remainingSegments","cachedSegment","cachedSegmentExpiration","countOverhead","cachedSegmentsCount","sort","a","b","defaultSettings","consumeOnly","simultaneousHttpDownloads","httpDownloadProbability","httpDownloadProbabilityInterval","httpDownloadProbabilitySkipIfNoPeers","httpDownloadMaxPriority","httpDownloadInitialTimeout","httpDownloadInitialTimeoutPerSegment","simultaneousP2PDownloads","p2pDownloadMaxPriority","config","debugSegments","segmentsQueue","bandwidthApproximator","httpDownloadInitialTimeoutTimestamp","Infinity","createHttpManager","createP2PManager","load","httpRandomDownloadInterval","setInterval","downloadRandomSegmentOverHttp","processInitialSegmentTimeout","p2pManager","updateSegmentsMap","find","f","httpManager","SegmentAbort","storageSegments","processSegmentsQueue","cleanSegmentsStorage","getSettings","getDetails","getBandwidthEstimate","clearInterval","httpAllowed","firstNotDownloadePriority","httpTimeout","segmentToAbort","pendingQueue","filter","method","SegmentStartLoad","PieceBytesDownloaded","PieceBytesUploaded","downloadBandwidth","SegmentLoaded","details","SegmentError","SegmentSize","getStreamSwarmId","streamId","addSegmentToMap","sequence","segmentsIdsAndStatuses","storageSegment","PeerConnect","PeerClose","incomplete","queueSegment","bufferedSegmentsCount","isSupported","window","RTCPeerConnection","prototype","createDataChannel","getByteRange","context","rangeEnd","rangeStart","compareByteRanges","b1","b2","byteRangeToString","byteRange","end","forwardSegmentCount","swarmId","assetsStorage","loader","masterPlaylist","variantPlaylists","segmentRequest","playQueue","segmentByteRange","onSuccess","onError","onSegmentAbort","content","parser","playlist","manifest","playlists","variantPlaylist","found","updateSegments","res","getMasterSwarmId","asset","getAsset","responseURL","responseUri","response","loadContent","text","storeAsset","masterManifestUri","requestUri","processPlaylist","segmentLocation","getSegmentLocation","byteRangeString","result","next","arrayBuffer","requestRange","segmentSequence","mediaSequence","segmentIndex","promise","Promise","resolve","reject","loadSegments","duration","urlIndex","findIndex","playPosition","playheadPosition","currentSegmentPosition","getSegmentIndex","requestFirstSegment","playlistSegments","initialSequence","loadSegmentId","max","getSegmentAbsoluteUrl","uri","byterange","getSegmentId","settingsSwarmId","playlistUrl","URL","fetchPromise","playlistRequestUrl","segmentManager","isLoaded","stats","loaded","total","aborted","retry","chunkCount","bwEstimate","loading","first","parsing","buffering","_config","callbacks","updateStatsToStartLoading","type","loadPlaylist","successPlaylist","e","frag","isSegment","updateStart","onUpdateSegmentSize","onUpdateLoaded","_type","loadSegment","successSegment","off","console","warn","abortSegment","onAbort","xhr","onProgress","map","eventKey","engine","impl","getResponseHeader","getEngine","setPlayingSegment","setPlayingSegmentByCurrentTime","version","initHlsJsPlayer","player","initHlsJsEvents","initClapprPlayer","playback","core","getCurrentPlayback","_hls","_p2pm_linitialized","initFlowplayerHlsJsPlayer","hlsjs","hls","initVideoJsContribHlsJsPlayer","ready","options","tech_","options_","hlsjsConfig","initVideoJsHlsJsPlugin","videojs","Html5Hlsjs","addHook","videojsPlayer","initMediaElementJsPlayer","mediaElement","addEventListener","hlsPlayer","media","currentTime","initJwPlayer","iid","assign","_event","errorData","htmlMediaElement","el_"],"mappings":";0FAiCA,IAAYA,E,oEAAZ,SAAYA,GAKR,iCAMA,+BAOA,6BAMA,+BAOA,wCAMA,6BAMA,yBAMA,gDAMA,4CAvDJ,CAAYA,MAAM,K,wDCbX,MAAM,UAA8C,eAA3D,c,oBACW,KAAAC,GAAK,CAACC,EAAUC,IAA6CC,MAAMH,GAAGC,EAAOC,GAC7E,KAAAE,KAAO,CAACH,KAAaI,IAAyBF,MAAMC,KAAKH,KAAUI,ICA9E,MAAM,UAAwB,GAIvB,MAAM,UAAyB,EAMlC,YACaC,GAUTH,QAVS,KAAAG,WANL,KAAAC,cAAgB,IAAIC,IACpB,KAAAC,eAAiB,IAAID,IACrB,KAAAE,MAAQ,IAAM,4BACd,KAAAC,MAAsB,IAAIN,IAASM,SAASN,GAoB7C,KAAAO,SAAW,CAACC,EAAkBC,KACjC,GAAIC,KAAKC,cAAcH,GACnB,OAGJE,KAAKE,8BAELF,KAAKX,KAAK,qBAAsBS,GAEhC,MAAMK,EAAaH,KAAKI,gBAAgBN,GAElCO,EAAa,IAAIC,gBAEvBN,KAAKR,cAAce,IAAIT,EAAQU,GAAI,CAAEH,aAAYP,UAASW,gBAAiBX,EAAQY,SAAUP,eAE7FH,KAAKL,MAAM,wBAAyBQ,GAEpCL,EAAQa,WAAaR,EAErB,MAAMS,EAAU,IAAIC,QAEpB,GAAIf,EAAQgB,MACRF,EAAQG,OAAO,QAASjB,EAAQgB,YAC7B,QAAyBE,IAArBjB,GAAkCC,KAAKT,SAAS0B,cAAe,CACtE,IAAIC,EAAkB,EACtB,IAAK,MAAMC,KAASpB,EAChBmB,GAAmBC,EAAMC,WAG7BR,EAAQG,OAAO,QAAS,SAASG,MAEjClB,KAAKL,MAAM,yBAA0BuB,QAErCnB,OAAmBiB,EAGvB,MAAMK,EAAShB,EAAWgB,OAEpBC,EAAetB,KAAKJ,MAAMO,EAAY,CAAES,UAASS,WAElDrB,KAAKuB,iBAAiBD,EAAcxB,EAASC,GAC7CyB,OAAOC,IAKJ,GAAiB,eAAbA,EAAIC,KAWR,GAAoB,kBAAhBD,EAAIE,QASR,GAAoB,oBAAhBF,EAAIE,aAAR,CASI3B,KAAKL,MAAM,uBAAwBG,GAEnC,MAAM8B,EAAaC,MAAM,gBAEzB7B,KAAK8B,eAAehC,EAAS8B,EAAY9B,EAAQiC,SAtBrD,CACI/B,KAAKL,MAAM,8CAA+CG,GAE1D,MAAMkC,EAAWH,MAAM,iBAEvB7B,KAAK8B,eAAehC,EAASkC,EAAUlC,EAAQiC,UAT/C/B,KAAKL,MAAM,sCAAuCG,MAmC9DE,KAAKR,cAAce,IAAIT,EAAQU,GAAI,CAAEyB,QAASX,EAAcjB,aAAYP,UAASW,gBAAiBX,EAAQY,SAAUP,gBAKjH,KAAA+B,eAAkBpC,IACrB,MAAMmC,EAAUjC,KAAKR,cAAc2C,IAAIrC,EAAQU,IAE/C,IAAKyB,EACD,MAAM,IAAIJ,MAAM,oDAAsD/B,EAAQU,IAM9EV,EAAQY,UAAYV,KAAKT,SAAS6C,0BAClCH,EAAQxB,gBAAkBT,KAAKT,SAAS6C,0BACxCH,EAAQ9B,aAAeH,KAAKI,gBAAgBN,KAE5CE,KAAKL,MAAM,4EAA6EG,EAAQU,IAChGR,KAAKqC,MAAMvC,GACXE,KAAKH,SAASC,KAKf,KAAAuC,MAASvC,IACZ,MAAMmC,EAAUjC,KAAKR,cAAc2C,IAAIrC,EAAQU,IAE3CyB,IACAA,EAAQ5B,WAAWgC,QACnBrC,KAAKR,cAAc8C,OAAOxC,EAAQU,IAClCR,KAAKL,MAAM,qBAAsBG,EAAQU,MAI1C,KAAAP,cAAiBH,GACbE,KAAKR,cAAc+C,IAAIzC,EAAQU,IAGnC,KAAAgC,SAAY1C,IACf,MAAM2C,EAAOzC,KAAKN,eAAeyC,IAAIrC,EAAQU,IAC7C,YAAgBQ,IAATyB,GAAsBA,EAAOzC,KAAK0C,OAGtC,KAAAC,mBAAqB,IACjB3C,KAAKR,cAGT,KAAAoD,wBAA0B,IACtB5C,KAAKR,cAAcqD,KAGvB,KAAAC,QAAU,KACb9C,KAAKR,cAAcuD,SAASd,GAAYA,EAAQ5B,WAAWgC,UAC3DrC,KAAKR,cAAcwD,SAGf,KAAAzB,iBAAmB,CAAO3B,EAA0BE,EAAkBC,IAAqC,4CAC/G,MAAMkD,QAAsBrD,EAEtBsD,EAAaD,EAAcE,KAAKC,YAEhCC,EAAmBJ,EAAcrC,QAAQuB,IAAI,kBAE7CmB,EAAgBC,OAAOC,WAAWH,GAElCI,EAAwB,IAAIC,WAAWJ,GAE7C,IAYIK,EAZAC,EAAe,EAEnB,GAAIC,MAAMC,QAAQ/D,IAA8C,MAAzBkD,EAAcc,OACjD,IAAK,MAAM5C,KAASpB,EAAkB,CAClC,MAAMiE,EAAa,IAAIN,WAAWvC,GAElCsC,EAAUlD,IAAIyD,EAAYJ,GAE1BA,EAAezC,EAAMC,WAM7B,OAASuC,QAAaT,EAAWS,QAAQM,MAAM,CAC3C,MAAMC,EAAaP,EAAKQ,MAExBV,EAAUlD,IAAI2D,EAAYN,GAE1BA,GAAgBM,EAAWE,OAI3BpE,KAAKX,KAAK,mBAAoBS,EAASoE,EAAWE,QAE9Cd,GACAtD,KAAKX,KAAK,eAAgBS,EAASwD,GAI3C,GAAIL,EAAcc,OAAS,KAAOd,EAAcc,QAAU,IAA1D,CACI,MAAMtC,EAAMI,MAAM,kCAAkCoB,EAAcc,UAClE/D,KAAK8B,eAAehC,EAAS2B,EAAKwB,EAAclB,gBAI9C/B,KAAKqE,wBAAwBvE,EAAS2D,EAAUa,OAAQrB,MAG1D,KAAAoB,wBAA0B,CAAOvE,EAAkByE,EAAmBtB,IAA4B,4CAGtG,GAFAnD,EAAQ0E,YAAcvB,EAAclB,IAEhC/B,KAAKT,SAASkF,iBACd,UACUzE,KAAKT,SAASkF,iBAAiB,OAAD,wBAAM3E,GAAO,CAAEyE,KAAMA,IAAQ,QACnE,MAAOG,GAGL,OAFA1E,KAAKL,MAAM,2BAA4B+E,QACvC1E,KAAK8B,eAAehC,EAAS4E,EAAOzB,EAAclB,KAK1D/B,KAAKR,cAAc8C,OAAOxC,EAAQU,IAClCR,KAAKX,KAAK,iBAAkBS,EAASyE,MAGjC,KAAAzC,eAAiB,CAAChC,EAAkB4E,EAAcF,KACtD1E,EAAQ0E,YAAcA,EAEtBxE,KAAKR,cAAc8C,OAAOxC,EAAQU,IAClCR,KAAKN,eAAea,IAAIT,EAAQU,GAAIR,KAAK0C,MAAQ1C,KAAKT,SAASoF,0BAC/D3E,KAAKX,KAAK,gBAAiBS,EAAS4E,IAGhC,KAAAxE,4BAA8B,KAClC,MAAMwC,EAAM1C,KAAK0C,MACXkC,EAAuB,GAE7B5E,KAAKN,eAAeqD,SAAQ,CAACN,EAAMjC,KAC3BiC,EAAOC,GACPkC,EAAWC,KAAKrE,MAIxBoE,EAAW7B,SAASvC,GAAOR,KAAKN,eAAe4C,OAAO9B,MAWlD,KAAAkC,IAAM,IAAMoC,YAAYpC,MAvPxBnD,EAASwF,iBACT/E,KAAKJ,MAAQL,EAASwF,gBA8OtB,gBAAiBjF,GACrB,OAAIE,KAAKT,SAASyF,kBACPhF,KAAKT,SAASyF,kBAAkBlF,GAGpCA,EAAQiC,K,ICxQlBkD,EA0BOC,E,6CA1BZ,SAAKD,GACD,iCACA,qCACA,iCACA,uCACA,mDALJ,CAAKA,MAAiB,KA0BtB,SAAYC,GACR,uBACA,qCAFJ,CAAYA,MAAsB,KAKlC,MAAMC,EAGF,YAAqB3E,EAAqBqC,GAArB,KAAArC,KAAqB,KAAAqC,OAFnC,KAAA3B,gBAAkB,EAClB,KAAAkE,OAAwB,IAI5B,MAAM,UAAkB,EAsB3B,YAEaC,EACA9F,GAKTH,QANS,KAAAiG,OACA,KAAA9F,WAVN,KAAA+F,cAAgB,GACf,KAAAC,qBAAsC,KACtC,KAAAC,mBAAgD,KAChD,KAAAC,YAAc,IAAIhG,IAClB,KAAAE,MAAQ,IAAM,oBACd,KAAA+F,MAA8C,KAoB9C,KAAAC,cAAgB,KACpB3F,KAAKL,MAAM,eAAgBK,KAAKQ,GAAIR,MACpCA,KAAKsF,cAAgBtF,KAAKqF,KAAKC,cAC/BtF,KAAKX,KAAK,UAAWW,OAGjB,KAAA4F,YAAc,KAClB5F,KAAKL,MAAM,aAAcK,KAAKQ,GAAIR,MAClCA,KAAK6F,0BACL7F,KAAKX,KAAK,QAASW,OAGf,KAAA8F,YAAepB,IACnB1E,KAAKL,MAAM,aAAcK,KAAKQ,GAAIkE,EAAO1E,OAGrC,KAAA+F,oBAAuBxB,IAC3B,IAAKvE,KAAKwF,mBAGN,YADAxF,KAAKL,MAAM,6BAA8BK,KAAKQ,GAAIR,MAItDA,KAAKwF,mBAAmBtE,iBAAmBqD,EAAKnD,WAChDpB,KAAKwF,mBAAmBJ,OAAOP,KAAKN,GAEpC,MAAMyB,EAAYhG,KAAKwF,mBAAmBhF,GAG1C,GAFAR,KAAKX,KAAK,mBAAoBW,KAAMgG,EAAWzB,EAAKnD,YAEhDpB,KAAKwF,mBAAmBtE,kBAAoBlB,KAAKwF,mBAAmB3C,KAAM,CAC1E,MAAMoD,EAAc,IAAIvC,WAAW1D,KAAKwF,mBAAmB3C,MAC3D,IAAIqD,EAAS,EACb,IAAK,MAAM/E,KAASnB,KAAKwF,mBAAmBJ,OACxCa,EAAY1F,IAAI,IAAImD,WAAWvC,GAAQ+E,GACvCA,GAAU/E,EAAMC,WAGpBpB,KAAKL,MAAM,6BAA8BK,KAAKQ,GAAIwF,EAAWhG,MAC7DA,KAAK6F,0BACL7F,KAAKX,KAAK,iBAAkBW,KAAMgG,EAAWC,EAAY3B,aAClDtE,KAAKwF,mBAAmBtE,gBAAkBlB,KAAKwF,mBAAmB3C,OACzE7C,KAAKL,MAAM,uCAAwCK,KAAKQ,GAAIwF,EAAWhG,MACvEA,KAAK6F,0BACL7F,KAAKX,KAAK,gBAAiBW,KAAMgG,EAAW,yCAI5C,KAAAG,eAAkB5B,IACtB,MAAM6B,EAAQ,IAAI1C,WAAWa,GAG7B,GAAiB,MAAb6B,EAAM,IAA2B,KAAbA,EAAM,IAA4C,MAA/BA,EAAM7B,EAAKnD,WAAa,GAC/D,IACI,OAAOiF,KAAKC,OAAM,IAAIC,aAAcC,OAAOjC,IAC7C,SACE,OAAO,KAIf,OAAO,MAGH,KAAAkC,WAAclC,IAClB,MAAMmC,EAAU1G,KAAKmG,eAAe5B,GAEpC,GAAgB,OAAZmC,EAAJ,CAKA,GAAI1G,KAAKwF,mBAAoB,CACzBxF,KAAKL,MAAM,oDAAqDK,KAAKQ,GAAIR,MAEzE,MAAMgG,EAAYhG,KAAKwF,mBAAmBhF,GAG1C,OAFAR,KAAK6F,+BACL7F,KAAKX,KAAK,gBAAiBW,KAAMgG,EAAW,gDAMhD,OAFAhG,KAAKL,MAAM,uBAAwBK,KAAKQ,GAAIkG,EAAS1G,MAE7C0G,EAAQC,GACZ,KAAK1B,EAAkB2B,YACnB5G,KAAKyF,YAAczF,KAAK6G,kBAAkBH,EAAQI,GAClD9G,KAAKX,KAAK,gBACV,MAEJ,KAAK4F,EAAkB8B,eACnB/G,KAAKX,KAAK,kBAAmBW,KAAM0G,EAAQM,GAC3C,MAEJ,KAAK/B,EAAkBgC,YAEfjH,KAAKuF,sBACLvF,KAAKuF,uBAAyBmB,EAAQM,GACjB,iBAAdN,EAAQQ,GACfR,EAAQQ,GAAK,IAEblH,KAAKwF,mBAAqB,IAAIL,EAAmBuB,EAAQM,EAAGN,EAAQQ,GACpElH,KAAKX,KAAK,qBAAsBW,KAAKwF,mBAAmBhF,IACxDR,KAAKX,KAAK,eAAgBW,KAAKwF,mBAAmBhF,GAAIR,KAAKwF,mBAAmB3C,MAC9E7C,KAAKmH,8BAET,MAEJ,KAAKlC,EAAkBmC,cACfpH,KAAKuF,sBAAwBvF,KAAKuF,uBAAyBmB,EAAQM,IACnEhH,KAAK6F,0BACL7F,KAAKyF,YAAYnD,OAAOoE,EAAQM,GAChChH,KAAKX,KAAK,iBAAkBW,KAAM0G,EAAQM,IAE9C,MAEJ,KAAK/B,EAAkBoC,4BA/CvBrH,KAAK+F,oBAAoBxB,IAwDzB,KAAAsC,kBAAqBS,IACzB,KAAMA,aAAoBC,QACtB,OAAO,IAAI9H,IAGf,MAAMgG,EAAc,IAAIhG,IAExB,IAAK,MAAM+H,KAAiBD,OAAOE,KAAKH,GAAW,CAC/C,MAAMI,EAAaJ,EAAqCE,GACxD,KACME,aAAqB7D,OACF,IAArB6D,EAAUtD,QACc,iBAAjBsD,EAAU,IACfA,EAAU,aAAc7D,OAE1B,OAAO,IAAIpE,IAGf,MAAMkI,EAAcD,EAAU,GAAGE,MAAM,KACjCC,EAAmBH,EAAU,GAEnC,GAAIC,EAAYvD,SAAWyD,EAAiBzD,OACxC,OAAO,IAAI3E,IAGf,IAAK,IAAIuH,EAAI,EAAGA,EAAIW,EAAYvD,OAAQ4C,IAAK,CACzC,MAAMc,EAAgBD,EAAiBb,GACvC,GAA6B,iBAAlBc,QAAwE9G,IAA1CkE,EAAuB4C,GAC5D,OAAO,IAAIrI,IAGfgG,EAAYlF,IAAI,GAAGiH,KAAiBG,EAAYX,KAAMc,IAI9D,OAAOrC,GAGH,KAAAsC,YAAerB,IACnB1G,KAAKL,MAAM,oBAAqBK,KAAKQ,GAAIkG,EAAS1G,MAClDA,KAAKqF,KAAK2C,MAAM3B,KAAK4B,UAAUvB,KAG5B,KAAA5D,QAAU,KACb9C,KAAKL,MAAM,eAAgBK,KAAKQ,GAAIR,MACpCA,KAAK6F,0BACL7F,KAAKqF,KAAKvC,WAGP,KAAAoF,wBAA0B,IACtBlI,KAAKuF,qBAGT,KAAA4C,eAAiB,IACbnI,KAAKyF,YAGT,KAAA2C,gBAAmB3C,IACtBzF,KAAK+H,YAAY,CAAEpB,EAAG1B,EAAkB2B,YAAaE,EAAGrB,KAGrD,KAAA4C,gBAAkB,CAACrC,EAAmBzB,KACzCvE,KAAK+H,YAAY,CACbpB,EAAG1B,EAAkBgC,YACrBD,EAAGhB,EACHkB,EAAG3C,EAAKnD,aAGZ,IAAIkH,EAAY/D,EAAKnD,WACrB,KAAOkH,EAAY,GAAG,CAClB,MAAMC,EACFD,GAAatI,KAAKT,SAASiJ,qBAAuBxI,KAAKT,SAASiJ,qBAAuBF,EACrFhE,EAAS,SAAOmE,KAAKlE,EAAMA,EAAKnD,WAAakH,EAAWC,GAE9DvI,KAAKqF,KAAK2C,MAAM1D,GAChBgE,GAAaC,EAGjBvI,KAAKX,KAAK,iBAAkBW,KAAMgG,EAAWzB,EAAKnD,aAG/C,KAAAsH,kBAAqB1C,IACxBhG,KAAK+H,YAAY,CAAEpB,EAAG1B,EAAkBmC,cAAeJ,EAAGhB,KAGvD,KAAA2C,eAAkB3C,IACrB,GAAIhG,KAAKuF,qBACL,MAAM,IAAI1D,MAAM,qCAAuC7B,KAAKuF,sBAGhEvF,KAAK+H,YAAY,CAAEpB,EAAG1B,EAAkB8B,eAAgBC,EAAGhB,IAC3DhG,KAAKuF,qBAAuBS,EAC5BhG,KAAK4I,2BAGF,KAAAC,qBAAuB,KAC1B,IAAIrD,EAEJ,GAAIxF,KAAKuF,qBAAsB,CAC3B,MAAMS,EAAYhG,KAAKuF,qBACvBC,EAAqBxF,KAAKwF,mBAAqBxF,KAAKwF,mBAAmBJ,YAASpE,EAChFhB,KAAK6F,0BACL7F,KAAK+H,YAAY,CAAEpB,EAAG1B,EAAkBoC,qBAAsBL,EAAGhB,IAGrE,OAAOR,GAGH,KAAAoD,wBAA0B,KAC9B5I,KAAK0F,MAAQoD,YAAW,KAEpB,GADA9I,KAAK0F,MAAQ,MACR1F,KAAKuF,qBACN,OAEJ,MAAMS,EAAYhG,KAAKuF,qBACvBvF,KAAK6I,uBACL7I,KAAKX,KAAK,kBAAmBW,KAAMgG,KACpChG,KAAKT,SAASwJ,4BAGb,KAAA5B,2BAA6B,KAC7BnH,KAAK0F,QACLsD,aAAahJ,KAAK0F,OAClB1F,KAAK0F,MAAQ,OAIb,KAAAG,wBAA0B,KAC9B7F,KAAKuF,qBAAuB,KAC5BvF,KAAKwF,mBAAqB,KAC1BxF,KAAKmH,8BApQLnH,KAAKqF,KAAKpG,GAAG,UAAWe,KAAK2F,eAC7B3F,KAAKqF,KAAKpG,GAAG,QAASe,KAAK4F,aAC3B5F,KAAKqF,KAAKpG,GAAG,QAASe,KAAK8F,aAC3B9F,KAAKqF,KAAKpG,GAAG,OAAQe,KAAKyG,YAE1BzG,KAAKQ,GAAK6E,EAAK7E,ICrEvB,MAEMyI,EAAyB,MADA,QAAQC,QAAQ,SAAUC,IAAM,IAAIC,SAASD,EAAG,IAAM,KAAME,OAAO,KAAIA,MAAM,EAAG,MAG/G,MAAMC,EACF,YAAqBC,EAAyBzJ,GAAzB,KAAAyJ,SAAyB,KAAAzJ,WAgB3C,MAAM,UAAwB,EAyBjC,YACY0J,EACAjK,GAURH,QAXQ,KAAAoK,kBACA,KAAAjK,WAdJ,KAAAkK,cAAqB,KACrB,KAAAC,MAAQ,IAAIjK,IACZ,KAAAkK,eAAiB,IAAIlK,IACrB,KAAAmK,oBAAsB,IAAInK,IAC1B,KAAA+H,cAA+B,KAE/B,KAAA7H,MAAQ,IAAM,2BACd,KAAAkK,qBAEG,KAwBJ,KAAAC,SAAW,IACP9J,KAAK0J,MAGT,KAAAK,UAAY,IACR,SAAOtB,KAAKzI,KAAKuJ,QAAQS,SAAS,OAGtC,KAAAC,iBAAmB,CAACzC,EAAuB0C,KAC9C,GAAIlK,KAAKwH,gBAAkBA,EACvB,OAGJxH,KAAK8C,SAAQ,GAEb9C,KAAKwH,cAAgBA,EACrBxH,KAAKkK,cAAgBA,EACrBlK,KAAKL,MAAM,kBAAmBK,KAAKwH,eAEnCxH,KAAK6J,qBAAuB,CACxBM,aAAa,GAGjB,MAAMN,EAAuB7J,KAAK6J,qBAM5BO,GAAW,IAAI,KAAOC,OAAO,IAA2BrK,KAAKwH,iBAAiB8C,SAG/ET,EAAqBM,YAGQ,OAAvBnK,KAAKyJ,gBACZzJ,KAAKyJ,cAAc3G,UACnB9C,KAAKyJ,cAAgB,OAJrBzJ,KAAK6J,qBAAuB,KAC5B7J,KAAKuK,aAAaH,KAOlB,KAAAG,aAAgBH,IACpB,IAAKpK,KAAKT,SAASiL,OACf,OAGJ,MAAMC,EAAgB,CAClBL,SAAU,SAAO3B,KAAK2B,EAAU,EAAG,IACnCb,OAAQ,SAAOd,KAAKzI,KAAKuJ,OAAQ,EAAG,IACpCmB,SAAU1K,KAAKT,SAASoL,gBACxBC,UAAW5K,KAAKT,SAASqL,UACzBC,KAAM,KACNC,gBAAiB,KACN,CAAEC,QAAS/K,KAAKT,SAASyL,2BAIxC,IAAIC,EAAmBjL,KAAKyJ,cAE5BzJ,KAAKyJ,cAAgB,IAAI,IAAOgB,GAChCzK,KAAKyJ,cAAcxK,GAAG,QAASe,KAAKkL,gBACpClL,KAAKyJ,cAAcxK,GAAG,UAAWe,KAAKmL,kBACtCnL,KAAKyJ,cAAcxK,GAAG,SAAUe,KAAKoL,iBACrCpL,KAAKyJ,cAAcxK,GAAG,OAAQe,KAAKqL,eAEnCrL,KAAKyJ,cAAc6B,QAEM,OAArBL,IACAA,EAAiBnI,UACjBmI,EAAmB,OAInB,KAAAC,eAAkBxG,IACtB1E,KAAKL,MAAM,gBAAiB+E,IAGxB,KAAAyG,iBAAoBI,IACxBvL,KAAKL,MAAM,kBAAmB4L,IAG1B,KAAAH,gBAAmB7G,IACvBvE,KAAKL,MAAM,iBAAkB4E,GAC7BvE,KAAKX,KAAK,iBAAkBkF,IAIxB,KAAA8G,cAAiBG,IAGrB,GAFAxL,KAAKL,MAAM,eAAgB6L,EAAYhL,GAAIgL,GAEvCxL,KAAK0J,MAAMnH,IAAIiJ,EAAYhL,IAG3B,OAFAR,KAAKL,MAAM,iCAAkC6L,EAAYhL,GAAIgL,QAC7DA,EAAY1I,UAIhB,MAAMuC,EAAO,IAAI,EAAUmG,EAAaxL,KAAKT,UAE7C8F,EAAKpG,GAAG,UAAWe,KAAK2F,eACxBN,EAAKpG,GAAG,QAASe,KAAK4F,aACtBP,EAAKpG,GAAG,eAAgBe,KAAKyL,mBAC7BpG,EAAKpG,GAAG,kBAAmBe,KAAK0L,kBAChCrG,EAAKpG,GAAG,iBAAkBe,KAAK2L,iBAC/BtG,EAAKpG,GAAG,iBAAkBe,KAAK4L,iBAC/BvG,EAAKpG,GAAG,gBAAiBe,KAAK6L,gBAC9BxG,EAAKpG,GAAG,eAAgBe,KAAK8L,eAC7BzG,EAAKpG,GAAG,qBAAsBe,KAAK+L,oBACnC1G,EAAKpG,GAAG,kBAAmBe,KAAKgM,kBAChC3G,EAAKpG,GAAG,mBAAoBe,KAAKiM,wBACjC5G,EAAKpG,GAAG,iBAAkBe,KAAKkM,sBAE/B,IAAIC,EAAqBnM,KAAK2J,eAAexH,IAAIkD,EAAK7E,IAEjD2L,IACDA,EAAqB,GACrBnM,KAAK2J,eAAepJ,IAAI8E,EAAK7E,GAAI2L,IAGrCA,EAAmBtH,KAAKQ,IAGrB,KAAAxF,SAAYC,IACf,GAAIE,KAAKC,cAAcH,GACnB,OAAO,EAGX,MAAM8E,EAA0B,GAEhC,IAAK,MAAMS,KAAQrF,KAAK0J,MAAM0C,SAEa,OAAnC/G,EAAK6C,2BACL7C,EAAK8C,iBAAiBhG,IAAIrC,EAAQU,MAAQ0E,EAAuBmH,QAEjEzH,EAAWC,KAAKQ,GAIxB,GAA0B,IAAtBT,EAAWR,OACX,OAAO,EAGX,MAAMiB,EAAOT,EAAW0H,KAAKC,MAAMD,KAAKE,SAAW5H,EAAWR,SAG9D,OAFAiB,EAAKsD,eAAe7I,EAAQU,IAC5BR,KAAK4J,oBAAoBrJ,IAAIT,EAAQU,GAAI,IAAI8I,EAAmBjE,EAAK7E,GAAIV,KAClE,GAGJ,KAAAuC,MAASvC,IACZ,IAAI0F,EACJ,MAAMiH,EAAqBzM,KAAK4J,oBAAoBzH,IAAIrC,EAAQU,IAChE,GAAIiM,EAAoB,CACpB,MAAMpH,EAAOrF,KAAK0J,MAAMvH,IAAIsK,EAAmBlD,QAC3ClE,IACAG,EAAqBH,EAAKwD,wBAE9B7I,KAAK4J,oBAAoBtH,OAAOxC,EAAQU,IAE5C,OAAOgF,GAGJ,KAAAvF,cAAiBH,GACbE,KAAK4J,oBAAoBrH,IAAIzC,EAAQU,IAGzC,KAAAoC,wBAA0B,IACtB5C,KAAK4J,oBAAoB/G,KAG7B,KAAAC,QAAU,CAAC4J,GAAc,KAC5B1M,KAAKwH,cAAgB,KAEjBxH,KAAKyJ,gBACLzJ,KAAKyJ,cAAckD,OACfD,GAEA1M,KAAKyJ,cAAcmD,mBAAmB,SACtC5M,KAAKyJ,cAAcmD,mBAAmB,WACtC5M,KAAKyJ,cAAcmD,mBAAmB,UACtC5M,KAAKyJ,cAAcmD,mBAAmB,UAEtC5M,KAAKyJ,cAAc3G,UACnB9C,KAAKyJ,cAAgB,OAIzBzJ,KAAK6J,uBACL7J,KAAK6J,qBAAqBM,aAAc,EACxCnK,KAAK6J,qBAAuB,MAGhC7J,KAAK0J,MAAM3G,SAASsC,GAASA,EAAKvC,YAClC9C,KAAK0J,MAAM1G,QAEXhD,KAAK4J,oBAAoB5G,QAEzB,IAAK,MAAM6J,KAAqB7M,KAAK2J,eAAeyC,SAChD,IAAK,MAAMU,KAAiBD,EACxBC,EAAchK,UAGtB9C,KAAK2J,eAAe3G,SAGjB,KAAA+J,qBAAwBtH,IAC3BzF,KAAK0J,MAAM3G,SAASsC,GAASA,EAAK+C,gBAAgB3C,MAG/C,KAAA2C,gBAAkB,CAACmB,EAAgB9D,KACtC,MAAMJ,EAAOrF,KAAK0J,MAAMvH,IAAIoH,GACxBlE,GACAA,EAAK+C,gBAAgB3C,IAItB,KAAAuH,sBAAwB,KAC3B,MAAMC,EAAqB,IAAIxN,IAE/B,IAAK,MAAM4F,KAAQrF,KAAK0J,MAAM0C,SAC1B,IAAK,MAAOpG,EAAW8B,KAAkBzC,EAAK8C,iBACtCL,IAAkB5C,EAAuBmH,OACzCY,EAAmB1M,IAAIyF,EAAWd,EAAuBmH,QACjDY,EAAmB9K,IAAI6D,IAC/BiH,EAAmB1M,IAAIyF,EAAWd,EAAuBgI,eAKrE,OAAOD,GAGH,KAAAhB,uBAAyB,CAAC5G,EAAiBW,EAAmBI,KAClE,MAAMqG,EAAqBzM,KAAK4J,oBAAoBzH,IAAI6D,GAEpDyG,GACAzM,KAAKX,KAAK,mBAAoBoN,EAAmB3M,QAASsG,EAAOf,EAAK7E,KAItE,KAAA0L,qBAAuB,CAAC7G,EAAiBW,EAAmBI,KAChE,MAAMqG,EAAqBzM,KAAK4J,oBAAoBzH,IAAI6D,GAGxDhG,KAAKX,KAAK,iBAAkBoN,EAAqBA,EAAmB3M,QAAU,KAAMsG,EAAOf,EAAK7E,KAI5F,KAAAmF,cAAiBN,IAGrB,GAFsBrF,KAAK0J,MAAMvH,IAAIkD,EAAK7E,IAKtC,OAFAR,KAAKL,MAAM,mDAAoD0F,EAAK7E,GAAI6E,QACxEA,EAAKvC,UAKT9C,KAAK0J,MAAMnJ,IAAI8E,EAAK7E,GAAI6E,GAGxB,MAAM8G,EAAqBnM,KAAK2J,eAAexH,IAAIkD,EAAK7E,IACxD,GAAI2L,EAAoB,CACpB,IAAK,MAAMW,KAAiBX,EACpBW,IAAkBzH,GAClByH,EAAchK,UAItB9C,KAAK2J,eAAerH,OAAO+C,EAAK7E,IAGpCR,KAAKX,KAAK,iBAAkB,CAAEmB,GAAI6E,EAAK7E,GAAI8E,cAAeD,EAAKC,iBAG3D,KAAAM,YAAeP,IACnB,GAAIrF,KAAK0J,MAAMvH,IAAIkD,EAAK7E,MAAQ6E,EAAM,CAGlC,MAAM8G,EAAqBnM,KAAK2J,eAAexH,IAAIkD,EAAK7E,IACxD,IAAK2L,EACD,OAGJ,MAAMgB,EAAQhB,EAAmBiB,QAAQ/H,GASzC,OARe,IAAX8H,GACAhB,EAAmBkB,OAAOF,EAAO,QAGH,IAA9BhB,EAAmB/H,QACnBpE,KAAK2J,eAAerH,OAAO+C,EAAK7E,KAMxC,IAAK,MAAO8M,EAAKnJ,KAAUnE,KAAK4J,oBACxBzF,EAAMoF,SAAWlE,EAAK7E,IACtBR,KAAK4J,oBAAoBtH,OAAOgL,GAIxCtN,KAAK0J,MAAMpH,OAAO+C,EAAK7E,IACvBR,KAAKX,KAAK,qBACVW,KAAKX,KAAK,cAAegG,EAAK7E,KAG1B,KAAAiL,kBAAoB,KACxBzL,KAAKX,KAAK,sBAGN,KAAAqM,iBAAmB,CAAOrG,EAAiBW,IAAsB,4CACrE,QAA2BhF,IAAvBhB,KAAKkK,cACL,OAGJ,MAAMpK,QAAgBE,KAAKwJ,gBAAgB+D,WAAWvH,EAAWhG,KAAKkK,eAClEpK,GAAWA,EAAQyE,KACnBc,EAAKgD,gBAAgBrC,EAAWlG,EAAQyE,MAExCc,EAAKqD,kBAAkB1C,MAIvB,KAAA2F,gBAAkB,CAAOtG,EAAiBW,EAAmBzB,IAAsB,4CACvF,MAAMkI,EAAqBzM,KAAK4J,oBAAoBzH,IAAI6D,GACxD,IAAKyG,EACD,OAGJ,MAAM3M,EAAU2M,EAAmB3M,QAEnC,GAAIE,KAAKT,SAASkF,iBACd,UACUzE,KAAKT,SAASkF,iBAAiB,OAAD,wBAAM3E,GAAO,CAAEyE,KAAMA,IAAQ,MAAOc,EAAK7E,IAC/E,MAAOkE,GAKL,OAJA1E,KAAKL,MAAM,2BAA4B+E,GACvC1E,KAAK4J,oBAAoBtH,OAAO0D,GAChChG,KAAKX,KAAK,gBAAiBS,EAAS4E,EAAOW,EAAK7E,SAChDR,KAAK4F,YAAYP,GAKzBrF,KAAK4J,oBAAoBtH,OAAO0D,GAChChG,KAAKX,KAAK,iBAAkBS,EAASyE,EAAMc,EAAK7E,OAG5C,KAAAoL,gBAAkB,CAACvG,EAAiBW,KACxChG,KAAK4J,oBAAoBtH,OAAO0D,GAChChG,KAAKX,KAAK,sBAGN,KAAAwM,eAAiB,CAACxG,EAAiBW,EAAmBwH,KAC1D,MAAMf,EAAqBzM,KAAK4J,oBAAoBzH,IAAI6D,GACpDyG,IACAzM,KAAK4J,oBAAoBtH,OAAO0D,GAChChG,KAAKX,KAAK,gBAAiBoN,EAAmB3M,QAAS0N,EAAanI,EAAK7E,MAIzE,KAAAsL,cAAgB,CAAC9F,EAAmBnD,KACxC,MAAM4J,EAAqBzM,KAAK4J,oBAAoBzH,IAAI6D,GAEpDyG,GACAzM,KAAKX,KAAK,eAAgBoN,EAAmB3M,QAAS+C,IAItD,KAAAkJ,mBAAqB,CAAC/F,EAAmBnD,KAC7C,MAAM4J,EAAqBzM,KAAK4J,oBAAoBzH,IAAI6D,GAEpDyG,GACAzM,KAAKX,KAAK,qBAAsBoN,EAAmB3M,QAAS+C,IAI5D,KAAAmJ,iBAAmB,CAAC3G,EAAiBW,KACzC,MAAMyG,EAAqBzM,KAAK4J,oBAAoBzH,IAAI6D,GACpDyG,IACAzM,KAAK4J,oBAAoBtH,OAAO0D,GAChCX,EAAKvC,UACD9C,KAAK0J,MAAMpH,OAAOmK,EAAmBlD,SACrCvJ,KAAKX,KAAK,uBApYlBW,KAAKuJ,OAAShK,EAASiL,OApD/B,WACI,MAAMiD,EAAkB,iEAGxB,IAAIlE,EAASN,EAEb,IAAK,IAAIjC,EAAI,EAAGA,EAJO,GAIciC,EAAuB7E,OAAQ4C,IAChEuC,GAAUkE,EAAgBC,OAAOpB,KAAKC,MAAMD,KAAKE,SAAWiB,EAAgBrJ,SAGhF,OAAO,IAAIuJ,aAAcC,OAAOrE,GAAQjF,OA0CJuJ,GAAmB,IAAIC,YAAY,GAE/D9N,KAAKL,MAAMoO,SACX/N,KAAKL,MAAM,UAAWK,KAAK+J,aAAa,IAAIxD,aAAcC,OAAOxG,KAAKuJ,UC3ElF,MAAM5J,EAAQ,IAAM,gCAEdqO,EAAkB,IAGxB,MAAMC,EACF,YAAqB9J,EAAwB+J,GAAxB,KAAA/J,QAAwB,KAAA+J,aAG1C,MAAMC,EAAb,cACY,KAAAC,UAA8B,GAC9B,KAAAC,gBAAkB,EAClB,KAAAC,cAAkC,GAEnC,KAAAC,SAAW,CAACnI,EAAe8H,KAM9B,IALAvO,EAAM,gBAAiByG,GAEvBpG,KAAKoO,UAAUvJ,KAAK,IAAIoJ,EAAe7H,EAAO8H,IAC9ClO,KAAKqO,iBAAmBjI,EAEjB8H,EAAYlO,KAAKoO,UAAU,GAAGF,UAAYF,GAE7ChO,KAAKqO,iBAAmBrO,KAAKoO,UAAUI,QAASrK,MAGpD,MAAMsK,EAAWnC,KAAKoC,IAAIV,EAAiBE,GAC3ClO,KAAKsO,cAAczJ,KAAK,IAAIoJ,EAAejO,KAAKqO,gBAAkBI,EAAUP,KAIzE,KAAAS,aAAgBT,IACnB,KAAqC,IAA9BlO,KAAKsO,cAAclK,QAAgB8J,EAAYlO,KAAKsO,cAAc,GAAGJ,UA5B3D,KA6BblO,KAAKsO,cAAcE,QAGvB,IAAII,EAAe,EACnB,IAAK,MAAMC,KAAa7O,KAAKsO,cACrBO,EAAU1K,MAAQyK,IAClBA,EAAeC,EAAU1K,OAMjC,OAFAxE,EAAM,qBAAsBiP,GAErBA,GAGJ,KAAAE,kBAAoB,IAChBd,EAGJ,KAAAe,mBAAqB,IAhDP,KCFlB,MAAM,EAGT,YACYxP,GAAA,KAAAA,WAHJ,KAAAyP,MAAQ,IAAIvP,IASb,KAAAwP,aAAsBnP,GAAoC,4CAC7DE,KAAKgP,MAAMzO,IAAIT,EAAQU,GAAI,CAAEV,UAASoP,aAAcpK,YAAYpC,WAG7D,KAAAyF,eAAiB,IAAwD,4CAC5E,OAAOnI,KAAKgP,SAGT,KAAAzB,WAAoB/M,GAA6C,4CACpE,MAAM2O,EAAYnP,KAAKgP,MAAM7M,IAAI3B,GAEjC,QAAkBQ,IAAdmO,EAKJ,OADAA,EAAUD,aAAepK,YAAYpC,MAC9ByM,EAAUrP,WAGd,KAAAsP,WAAoB5O,GAAiC,4CACxD,OAAOR,KAAKgP,MAAMzM,IAAI/B,MAGnB,KAAA6O,MAAQ,CAAOnF,EAAuBoF,IAAqE,4CAC9G,MAAMC,EAA6B,GAC7BC,EAAkE,GAGlE9M,EAAMoC,YAAYpC,MAExB,IAAK,MAAM+M,KAAiBzP,KAAKgP,MAAM5C,SAC/B1J,EAAM+M,EAAcP,aAAelP,KAAKT,SAASmQ,wBACjDH,EAAiB1K,KAAK4K,EAAc3P,QAAQU,IAE5CgP,EAAkB3K,KAAK4K,GAK/B,IAAIE,EAAgBH,EAAkBpL,OAASpE,KAAKT,SAASqQ,oBAC7D,GAAID,EAAgB,EAAG,CACnBH,EAAkBK,MAAK,CAACC,EAAGC,IAAMD,EAAEZ,aAAea,EAAEb,eAEpD,IAAK,MAAMO,KAAiBD,EACxB,SAA6BxO,IAAzBsO,IAAuCA,EAAqBG,EAAc3P,QAAQU,OAClF+O,EAAiB1K,KAAK4K,EAAc3P,QAAQU,IAC5CmP,IACsB,IAAlBA,GACA,MAOhB,OADAJ,EAAiBxM,SAASvC,GAAOR,KAAKgP,MAAM1M,OAAO9B,KAC5C+O,EAAiBnL,OAAS,KAG9B,KAAAtB,QAAU,IAA2B,4CACxC9C,KAAKgP,MAAMhM,YC/BnB,MAAMgN,EAA4E,CAC9EN,wBAAyB,IACzBE,oBAAqB,IAErBpF,QAAQ,EACRyF,aAAa,EAEb7N,yBAA0B,EAE1B8N,0BAA2B,EAC3BC,wBAAyB,IACzBC,gCAAiC,IACjCC,sCAAsC,EACtC1L,yBAA0B,KAC1B2L,wBAAyB,GACzBC,2BAA4B,EAC5BC,qCAAsC,IACtCvP,eAAe,EAEfwP,yBAA0B,GAC1BC,uBAAwB,GACxB3H,0BAA2B,IAE3BP,qBAAsB,MACtBmC,gBAAiB,CAAC,8BAA+B,oCACjDK,wBAAyB,GACzBJ,UAAY,IAAsC+F,QAG/C,MAAM,UAAqB,eAiB9B,YAAmBpR,EAA8E,IAC7FH,QAjBa,KAAAO,MAAQ,IAAM,uBACd,KAAAiR,cAAgB,IAAM,gCAI/B,KAAAC,cAA2B,GAClB,KAAAC,sBAAwB,IAAI3C,EAGrC,KAAA4C,qCAAuCC,IAkEvC,KAAAC,kBAAoB,IACjB,IAAI,EAAiBjR,KAAKT,UAG7B,KAAA2R,iBAAmB,IAChB,IAAI,EAAgBlR,KAAKwJ,gBAAiBxJ,KAAKT,UAGnD,KAAA4R,KAAO,CAAO7J,EAAqBE,IAAyC,iDACvCxG,IAApChB,KAAKoR,6BAELpR,KAAKoR,2BAA6BC,YAC9BrR,KAAKsR,8BACLtR,KAAKT,SAAS6Q,iCAIdpQ,KAAKT,SAASgR,2BAA6B,GAC3CvQ,KAAKT,SAASiR,qCAAuC,IAGrDxQ,KAAK4Q,cACD,uCACA5Q,KAAKT,SAASgR,2BACd,cACAvQ,KAAKT,SAASiR,sCAElBxQ,KAAK+Q,oCAAsC/Q,KAAK0C,MAChDoG,WAAW9I,KAAKuR,6BAA8BvR,KAAKT,SAASiR,qCAAuC,OAIvGlJ,EAASlD,OAAS,IAClBpE,KAAKkK,cAAgB5C,EAAS,GAAG4C,oBAGVlJ,IAAvBhB,KAAKkK,eACLlK,KAAKwR,WAAWvH,iBAAiBzC,EAAexH,KAAKkK,eAGzDlK,KAAKL,MAAM,iBAEX,IAAI8R,GAAoB,EAGxB,IAAK,MAAM3R,KAAWE,KAAK6Q,cAClBvJ,EAASoK,MAAMC,GAAMA,EAAE5P,MAAQjC,EAAQiC,QACxC/B,KAAKL,MAAM,iBAAkBG,EAAQiC,KACjC/B,KAAK4R,YAAY3R,cAAcH,IAC/B2R,GAAoB,EACpBzR,KAAK4R,YAAYvP,MAAMvC,IAEvBE,KAAKwR,WAAWnP,MAAMvC,GAE1BE,KAAKX,KAAKL,EAAO6S,aAAc/R,IAIvC,GAAIE,KAAKL,MAAMoO,QACX,IAAK,MAAMjO,KAAWwH,EACbtH,KAAK6Q,cAAca,MAAMC,GAAMA,EAAE5P,MAAQjC,EAAQiC,OAClD/B,KAAKL,MAAM,cAAeG,EAAQiC,KAO9C,GAFA/B,KAAK6Q,cAAgBvJ,OAEMtG,IAAvBhB,KAAKkK,cACL,OAGJ,IAAI4H,QAAwB9R,KAAKwJ,gBAAgBrB,eAAenI,KAAKkK,eACrEuH,EAAoBzR,KAAK+R,qBAAqBD,IAAoBL,SAExDzR,KAAKgS,0BACXF,QAAwB9R,KAAKwJ,gBAAgBrB,eAAenI,KAAKkK,eACjEuH,GAAoB,GAGpBA,IAAsBzR,KAAKT,SAAS0Q,aACpCjQ,KAAKwR,WAAWzE,qBAAqB/M,KAAK6G,kBAAkBiL,OAI7D,KAAAvE,WAAoB/M,GAA6C,4CACpE,YAA8BQ,IAAvBhB,KAAKkK,mBAA8BlJ,EAAYhB,KAAKwJ,gBAAgB+D,WAAW/M,EAAIR,KAAKkK,kBAG5F,KAAA+H,YAAc,IACVjS,KAAKT,SAGT,KAAA2S,WAAa,KACT,CACH3I,OAAQvJ,KAAKwR,WAAWzH,cAIzB,KAAAoI,qBAAuB,IACnBnS,KAAK8Q,sBAAsBnC,aAAa3O,KAAK0C,OAGjD,KAAAI,QAAU,IAA2B,iDACA9B,IAApChB,KAAKoR,6BACLgB,cAAcpS,KAAKoR,4BACnBpR,KAAKoR,gCAA6BpQ,GAGtChB,KAAK+Q,qCAAuCC,IAE5ChR,KAAK6Q,cAAgB,GACrB7Q,KAAK4R,YAAY9O,UACjB9C,KAAKwR,WAAW1O,UAChB9C,KAAKkK,mBAAgBlJ,QACfhB,KAAKwJ,gBAAgB1G,aAGvB,KAAAyO,6BAA+B,IAAY,4CAC/C,QAAwCvQ,IAApChB,KAAKoR,2BAAT,CAIA,QAA2BpQ,IAAvBhB,KAAKkK,cAA6B,CAClC,MAAM4H,QAAwB9R,KAAKwJ,gBAAgBrB,eAAenI,KAAKkK,eAEnElK,KAAK+R,qBAAqBD,KAAqB9R,KAAKT,SAAS0Q,aAC7DjQ,KAAKwR,WAAWzE,qBAAqB/M,KAAK6G,kBAAkBiL,IAIhE9R,KAAK+Q,uCAAyCC,KAE9ClI,WAAW9I,KAAKuR,6BAA8BvR,KAAKT,SAASiR,0CAI5D,KAAAuB,qBAAwBD,IAM5B,GALA9R,KAAK4Q,cACD,mCACA5Q,KAAK6Q,cAAczM,OAAS,EAAIpE,KAAK6Q,cAAc,GAAGnQ,SAAW,QAG1CM,IAAvBhB,KAAKkK,eAA6D,IAA9BlK,KAAK6Q,cAAczM,OACvD,OAAO,EAGX,IACIqB,EADAgM,GAAoB,EAGpBY,GAAc,EAElB,GAAIrS,KAAK+Q,uCAAyCC,IAAU,CACxD,IAAIsB,EAEJ,IAAK,MAAMxS,KAAWE,KAAK6Q,cACvB,IAAKiB,EAAgBvP,IAAIzC,EAAQU,IAAK,CAClC8R,EAA4BxS,EAAQY,SACpC,MAIR,MAAM6R,EAAcvS,KAAK0C,MAAQ1C,KAAK+Q,oCACtCsB,EACIE,GAAevS,KAAKT,SAASgR,iCACEvP,IAA9BsR,GACGC,EAAcvS,KAAKT,SAASiR,sCAC5B8B,GAA6B,EAEjCD,IACArS,KAAK4Q,cAAc,oDACnB5Q,KAAK+Q,qCAAuCC,KAIpD,IAAK,IAAI7D,EAAQ,EAAGA,EAAQnN,KAAK6Q,cAAczM,OAAQ+I,IAAS,CAC5D,MAAMrN,EAAUE,KAAK6Q,cAAc1D,GAEnC,IAAI2E,EAAgBvP,IAAIzC,EAAQU,IAKhC,GAAIR,KAAK4R,YAAY3R,cAAcH,GAC/BE,KAAK4R,YAAY1P,eAAepC,OADpC,CAKA,GACIA,EAAQY,UAAYV,KAAKT,SAAS6C,0BAClCiQ,IACCrS,KAAK4R,YAAYpP,SAAS1C,GAC7B,CAEE,GAAIE,KAAK4R,YAAYhP,2BAA6B5C,KAAKT,SAAS2Q,0BAE5D,IAAK,IAAIlJ,EAAIhH,KAAK6Q,cAAczM,OAAS,EAAG4C,EAAImG,EAAOnG,IAAK,CACxD,MAAMwL,EAAiBxS,KAAK6Q,cAAc7J,GAC1C,GAAIhH,KAAK4R,YAAY3R,cAAcuS,GAAiB,CAChDxS,KAAK4Q,cAAc,uBAAwB4B,EAAe9R,SAAU8R,EAAezQ,KACnF/B,KAAK4R,YAAYvP,MAAMmQ,GACvB,OAKZ,GAAIxS,KAAK4R,YAAYhP,0BAA4B5C,KAAKT,SAAS2Q,0BAA2B,CAEtF,MAAMnQ,EAAmBC,KAAKwR,WAAWnP,MAAMvC,GAC/CE,KAAK4R,YAAY/R,SAASC,EAASC,GACnCC,KAAK4Q,cAAc,2BAA4B9Q,EAAQY,SAAUZ,EAAQiC,KACzE0P,GAAoB,EACpB,UAIR,IAAIzR,KAAKwR,WAAWvR,cAAcH,GAIlC,GAAIA,EAAQY,UAAYV,KAAKT,SAAS6C,yBAAtC,CAII,GAFAqD,EAAcA,GAA4BzF,KAAKwR,WAAWxE,wBAEtDvH,EAAYtD,IAAIrC,EAAQU,MAAQ0E,EAAuBmH,OACvD,SAGJ,GAAIrM,KAAKwR,WAAW5O,2BAA6B5C,KAAKT,SAASkR,yBAE3D,IAAK,IAAIzJ,EAAIhH,KAAK6Q,cAAczM,OAAS,EAAG4C,EAAImG,EAAOnG,IAAK,CACxD,MAAMwL,EAAiBxS,KAAK6Q,cAAc7J,GAC1C,GAAIhH,KAAKwR,WAAWvR,cAAcuS,GAAiB,CAC/CxS,KAAK4Q,cAAc,sBAAuB4B,EAAe9R,SAAU8R,EAAezQ,KAClF/B,KAAKwR,WAAWnP,MAAMmQ,GACtB,OAKZ,GAAIxS,KAAKwR,WAAW5O,0BAA4B5C,KAAKT,SAASkR,0BACtDzQ,KAAKwR,WAAW3R,SAASC,GAAU,CACnCE,KAAK4Q,cAAc,0BAA2B9Q,EAAQY,SAAUZ,EAAQiC,KACxE,eAQR/B,KAAKwR,WAAW5O,0BAA4B5C,KAAKT,SAASkR,0BAC1D3Q,EAAQY,UAAYV,KAAKT,SAASmR,wBAE9B1Q,KAAKwR,WAAW3R,SAASC,IACzBE,KAAK4Q,cAAc,eAAgB9Q,EAAQY,SAAUZ,EAAQiC,MAKzE,OAAO0P,GAGH,KAAAH,8BAAgC,IAAY,4CAChD,QAC2BtQ,IAAvBhB,KAAKkK,oBAC+BlJ,IAApChB,KAAKoR,4BACLpR,KAAK+Q,uCAAyCC,KAC9ChR,KAAK4R,YAAYhP,2BAA6B5C,KAAKT,SAAS2Q,2BAC3DlQ,KAAKT,SAAS8Q,sCAA4E,IAApCrQ,KAAKwR,WAAW1H,WAAWjH,MAClF7C,KAAKT,SAAS0Q,YAEd,OAGJ,MAAM6B,QAAwB9R,KAAKwJ,gBAAgBrB,eAAenI,KAAKkK,eACjEzE,EAAczF,KAAKwR,WAAWxE,wBAE9ByF,EAAezS,KAAK6Q,cAAc6B,QACnCxL,IACIlH,KAAKwR,WAAWvR,cAAciH,KAC9BlH,KAAK4R,YAAY3R,cAAciH,KAC/BzB,EAAYlD,IAAI2E,EAAE1G,MAClBR,KAAK4R,YAAYpP,SAAS0E,IAC3BA,EAAExG,UAAYV,KAAKT,SAAS+Q,0BAC3BwB,EAAgBvP,IAAI2E,EAAE1G,MAG/B,GAA4B,IAAxBiS,EAAarO,OACb,OAGJ,GAAIkI,KAAKE,SAAWxM,KAAKT,SAAS4Q,wBAA0BsC,EAAarO,OACrE,OAGJ,MAAMtE,EAAU2S,EAAanG,KAAKC,MAAMD,KAAKE,SAAWiG,EAAarO,SACrEpE,KAAK4Q,cAAc,yBAA0B9Q,EAAQY,SAAUZ,EAAQiC,KACvE/B,KAAK4R,YAAY/R,SAASC,GAC1BE,KAAKwR,WAAWzE,qBAAqB/M,KAAK6G,kBAAkBiL,OAGxD,KAAA/F,mBAAqB,CAAC4G,EAAwB7S,KAClDE,KAAKX,KAAKL,EAAO4T,iBAAkBD,EAAQ7S,IAGvC,KAAAmM,uBAAyB,CAAC0G,EAAwB7S,EAAkBsG,EAAemD,KACvFvJ,KAAK8Q,sBAAsBvC,SAASnI,EAAOpG,KAAK0C,OAChD1C,KAAKX,KAAKL,EAAO6T,qBAAsBF,EAAQ7S,EAASsG,EAAOmD,IAI3D,KAAA2C,qBAAuB,CAACyG,EAAe7S,EAAkBsG,EAAemD,KAC5EvJ,KAAKX,KAAKL,EAAO8T,mBAAoBH,EAAQ7S,EAASsG,EAAOmD,IAGzD,KAAAoC,gBAAkB,CAAO7L,EAAkByE,EAAmBgF,IAAoB,4CAGtF,GAFAvJ,KAAK4Q,cAAc,iBAAkB9Q,EAAQU,GAAIV,EAAQiC,UAE9Bf,IAAvBhB,KAAKkK,cACL,OAGJpK,EAAQyE,KAAOA,EACfzE,EAAQiT,kBAAoB/S,KAAK8Q,sBAAsBnC,aAAa3O,KAAK0C,aAEnE1C,KAAKwJ,gBAAgByF,aAAanP,GACxCE,KAAKX,KAAKL,EAAOgU,cAAelT,EAASyJ,GAEzC,MAAMuI,QAAwB9R,KAAKwJ,gBAAgBrB,eAAenI,KAAKkK,eAEvElK,KAAK+R,qBAAqBD,GACrB9R,KAAKT,SAAS0Q,aACfjQ,KAAKwR,WAAWzE,qBAAqB/M,KAAK6G,kBAAkBiL,OAI5D,KAAAjG,eAAiB,CAAO/L,EAAkBmT,EAAkB1J,IAAoB,4CAGpF,GAFAvJ,KAAK4Q,cAAc,gBAAiB9Q,EAAQU,GAAIV,EAAQiC,IAAKwH,EAAQ0J,GACrEjT,KAAKX,KAAKL,EAAOkU,aAAcpT,EAASmT,EAAS1J,QACtBvI,IAAvBhB,KAAKkK,cAA6B,CAClC,MAAM4H,QAAwB9R,KAAKwJ,gBAAgBrB,eAAenI,KAAKkK,eACnElK,KAAK+R,qBAAqBD,KAAqB9R,KAAKT,SAAS0Q,aAC7DjQ,KAAKwR,WAAWzE,qBAAqB/M,KAAK6G,kBAAkBiL,QAKhE,KAAAhG,cAAgB,CAAOhM,EAAkB+C,IAAiB,4CAC9D7C,KAAK4Q,cAAc,eAAgB9Q,EAAQU,GAAIqC,GAC/C7C,KAAKX,KAAKL,EAAOmU,YAAarT,EAAS+C,MAGnC,KAAAuQ,iBAAoBtT,QACIkB,IAArBlB,EAAQuT,SAAyBvT,EAAQoK,cAAgB,GAAGpK,EAAQoK,iBAAiBpK,EAAQuT,WAGhG,KAAAxM,kBAAqBiL,IACzB,MAAMrM,EAAqD,GAErD6N,EAAkB,CAACxT,EAAkBiE,KACvC,MAAMyD,EAAgBxH,KAAKoT,iBAAiBtT,GACtCkG,EAAYlG,EAAQyT,SAE1B,IAAIC,EAAyB/N,EAAY+B,QACVxG,IAA3BwS,IACAA,EAAyB,CAAC,GAAI,IAC9B/N,EAAY+B,GAAiBgM,GAEjC,MAAM3L,EAAmB2L,EAAuB,GAChDA,EAAuB,IAAkC,IAA5B3L,EAAiBzD,OAAe4B,EAAY,IAAIA,IAC7E6B,EAAiBhD,KAAKd,IAG1B,IAAK,MAAM0P,KAAkB3B,EAAgB1F,SACzCkH,EAAgBG,EAAe3T,QAASoF,EAAuBmH,QAGnE,IAAK,MAAMxM,KAAYG,KAAK4R,YAAYjP,qBAAqByJ,SACzDkH,EAAgBzT,EAASC,QAASoF,EAAuBgI,eAG7D,OAAOzH,GAGH,KAAAE,cAAuBN,GAAyB,4CACpDrF,KAAKX,KAAKL,EAAO0U,YAAarO,GACzBrF,KAAKT,SAAS0Q,kBAAsCjP,IAAvBhB,KAAKkK,eACnClK,KAAKwR,WAAWpJ,gBACZ/C,EAAK7E,GACLR,KAAK6G,wBAAwB7G,KAAKwJ,gBAAgBrB,eAAenI,KAAKkK,oBAK1E,KAAAtE,YAAe2D,IACnBvJ,KAAKX,KAAKL,EAAO2U,UAAWpK,IAGxB,KAAA6B,gBAAyB7G,GAAkC,4CAC/D,GACIvE,KAAK+Q,uCAAyCC,UAC1BhQ,IAApBuD,EAAKqP,YACLrP,EAAKqP,YAAc,IAEnB5T,KAAK4Q,cAAc,mDAEnB5Q,KAAK+Q,qCAAuCC,SAEjBhQ,IAAvBhB,KAAKkK,eAA6B,CAClC,MAAM4H,QAAwB9R,KAAKwJ,gBAAgBrB,eAAenI,KAAKkK,eAEnElK,KAAK+R,qBAAqBD,KAAqB9R,KAAKT,SAAS0Q,aAC7DjQ,KAAKwR,WAAWzE,qBAAqB/M,KAAK6G,kBAAkBiL,QAMpE,KAAAE,qBAAuB,IAA8B,4CACzD,YAA2BhR,IAAvBhB,KAAKkK,eAIFlK,KAAKwJ,gBAAgB6F,MACxBrP,KAAKkK,eACJ1J,QAAqFQ,IAAtEhB,KAAK6Q,cAAca,MAAMmC,GAAiBA,EAAarT,KAAOA,SAI9E,KAAAkC,IAAM,IACHoC,YAAYpC,MAvenB1C,KAAKT,SAAW,OAAH,wBAAQyQ,GAAoBzQ,GAEzC,MAAM,sBAAEuU,GAA0BvU,EAEG,iBAA1BuU,SACiC9S,IAApCzB,EAASmR,yBACT1Q,KAAKT,SAASmR,uBAAyBoD,QAGF9S,IAArCzB,EAAS+Q,0BACTtQ,KAAKT,SAASmR,uBAAyBoD,IAI/C9T,KAAKwJ,qBACiCxI,IAAlChB,KAAKT,SAASiK,gBACR,IAAI,EAAsBxJ,KAAKT,UAC/BS,KAAKT,SAASiK,gBAExBxJ,KAAKL,MAAM,kBAAmBK,KAAKT,UAEnCS,KAAK4R,YAAc5R,KAAKiR,oBACxBjR,KAAK4R,YAAY3S,GAAG,sBAAuBa,GAAqBE,KAAK+L,mBAAmB,OAAQjM,KAChGE,KAAK4R,YAAY3S,GAAG,iBAAkBe,KAAK2L,iBAC3C3L,KAAK4R,YAAY3S,GAAG,gBAAiBe,KAAK6L,gBAC1C7L,KAAK4R,YAAY3S,GAAG,eAAgBe,KAAK8L,eACzC9L,KAAK4R,YAAY3S,GAAG,oBAAoB,CAACa,EAAkBsG,KACvDpG,KAAKiM,uBAAuB,OAAQnM,EAASsG,MAGjDpG,KAAKwR,WAAaxR,KAAKkR,mBACvBlR,KAAKwR,WAAWvS,GAAG,sBAAuBa,GAAqBE,KAAK+L,mBAAmB,MAAOjM,KAC9FE,KAAKwR,WAAWvS,GAAG,iBAAkBe,KAAK2L,iBAC1C3L,KAAKwR,WAAWvS,GAAG,gBAAiBe,KAAK6L,gBACzC7L,KAAKwR,WAAWvS,GAAG,eAAgBe,KAAK8L,eACxC9L,KAAKwR,WAAWvS,GAAG,qBAAqB,IAAY,4CAChD,QAA2B+B,IAAvBhB,KAAKkK,cACL,OAGJ,MAAM4H,QAAwB9R,KAAKwJ,gBAAgBrB,eAAenI,KAAKkK,eACnElK,KAAK+R,qBAAqBD,KAAqB9R,KAAKT,SAAS0Q,aAC7DjQ,KAAKwR,WAAWzE,qBAAqB/M,KAAK6G,kBAAkBiL,SAGpE9R,KAAKwR,WAAWvS,GAAG,oBAAoB,CAACa,EAAkBsG,EAAemD,IACrEvJ,KAAKiM,uBAAuB,MAAOnM,EAASsG,EAAOmD,KAEvDvJ,KAAKwR,WAAWvS,GAAG,kBAAkB,CAACa,EAAkBsG,EAAemD,IACnEvJ,KAAKkM,qBAAqB,MAAOpM,EAASsG,EAAOmD,KAErDvJ,KAAKwR,WAAWvS,GAAG,iBAAkBe,KAAK2F,eAC1C3F,KAAKwR,WAAWvS,GAAG,cAAee,KAAK4F,aACvC5F,KAAKwR,WAAWvS,GAAG,iBAAkBe,KAAKoL,kBA5DhC,EAAA2I,YAAc,SACwC/S,IAAzDgT,OAAOC,kBAAkBC,UAAUC,mB,kuBChG3C,SAASC,EAAaC,GAC3B,OAAOA,EAAQC,eAAmCtT,IAAvBqT,EAAQE,WAC7B,CAAErO,OAAQmO,EAAQE,WAAYnQ,OAAQiQ,EAAQC,SAAWD,EAAQE,iBACjEvT,EAGD,SAASwT,EAAkBC,EAAeC,GAC/C,YAAc1T,IAAPyT,OAA0BzT,IAAP0T,OAA0B1T,IAAP0T,GAAoBD,EAAGrQ,SAAWsQ,EAAGtQ,QAAUqQ,EAAGvO,SAAWwO,EAAGxO,OAGxG,SAASyO,EAAkBC,GAChC,QAAkB5T,IAAd4T,EACA,OAGJ,MAAMC,EAAMD,EAAU1O,OAAS0O,EAAUxQ,OAAS,EAElD,MAAO,SAASwQ,EAAU1O,UAAU2O,ICAtC,MAAM7E,EAA0C,CAC5C8E,oBAAqB,GACrBC,aAAS/T,EACTgU,mBAAehU,GAGZ,MAAM,EAiBT,YAAmBiU,EAAyB1V,EAAyC,IAf7E,KAAA2V,eAAkC,KACzB,KAAAC,iBAAmB,IAAI1V,IAChC,KAAA2V,eAAwC,KAC/B,KAAAxV,MAAsB,IAAIN,IAASM,SAASN,GACrD,KAAA+V,UAQF,GA8QE,KAAA1J,gBAAmB7L,IAEnBE,KAAKoV,gBACLpV,KAAKoV,eAAejV,aAAeL,EAAQiC,KAC3C4S,EAAkB3U,KAAKoV,eAAeE,oBAAsBxV,EAAQgB,QAGpEd,KAAKoV,eAAeG,UAAUzV,EAAQyE,KAAM8E,MAAM,GAAIvJ,EAAQiT,mBAC9D/S,KAAKoV,eAAiB,OAItB,KAAAvJ,eAAiB,CAAC/L,EAAkB4E,KAEpC1E,KAAKoV,gBACLpV,KAAKoV,eAAejV,aAAeL,EAAQiC,KAC3C4S,EAAkB3U,KAAKoV,eAAeE,oBAAsBxV,EAAQgB,QAEpEd,KAAKoV,eAAeI,QAAQ9Q,GAC5B1E,KAAKoV,eAAiB,OAItB,KAAAK,eAAkB3V,IAElBE,KAAKoV,gBACLpV,KAAKoV,eAAejV,aAAeL,EAAQiC,KAC3C4S,EAAkB3U,KAAKoV,eAAeE,oBAAsBxV,EAAQgB,QAEpEd,KAAKoV,eAAeI,QAAQ,mCAC5BxV,KAAKoV,eAAiB,OAxS1BpV,KAAKT,SAAW,OAAH,wBAAQyQ,GAAoBzQ,EAAS+H,UAElDtH,KAAKiV,OAASA,EACdjV,KAAKiV,OAAOhW,GAAG,IAAO+T,cAAehT,KAAK2L,iBAC1C3L,KAAKiV,OAAOhW,GAAG,IAAOiU,aAAclT,KAAK6L,gBACzC7L,KAAKiV,OAAOhW,GAAG,IAAO4S,aAAc7R,KAAKyV,gBAErClW,EAAS0V,QAAU1V,EAAS0V,OAAOlQ,iBACnC/E,KAAKJ,MAAQL,EAAS0V,OAAOlQ,gBAI9B,cACH,OAAO/E,KAAKT,SAGT,gBAAgBoB,EAAoB+U,EAAiBlR,GACxD,MAAMmR,EAAS,IAAI,IACnBA,EAAO9Q,KAAK6Q,GACZC,EAAOd,MAEP,MAAMe,EAAW,IAAI,EAASjV,EAAY6D,EAAamR,EAAOE,UAE9D,GAAID,EAASC,SAASC,UAAW,CAC7B9V,KAAKkV,eAAiBU,EAEtB,IAAK,MAAOtI,EAAKyI,KAAoB/V,KAAKmV,iBAAkB,CACxD,MAAM,cAAE3N,EAAa,MAAEwO,EAAK,MAAE7I,GAAUnN,KAAKoT,iBAAiB2C,EAAgBpV,YACzEqV,GAGDD,EAAgBvO,cAAgBA,EAChCuO,EAAgB1C,SAAW,IAAMlG,EAAMnD,YAHvChK,KAAKmV,iBAAiB7S,OAAOgL,QAMlC,CACH,MAAM,cAAE9F,EAAa,MAAEwO,EAAK,MAAE7I,GAAUnN,KAAKoT,iBAAiBzS,IAE1DqV,GAAiC,OAAxBhW,KAAKkV,kBAEdU,EAASpO,cAAgBA,EACzBoO,EAASvC,SAAmC,OAAxBrT,KAAKkV,oBAA0BlU,EAAY,IAAMmM,EAAMnD,WAC3EhK,KAAKmV,iBAAiB5U,IAAII,EAAYiV,GACtC5V,KAAKiW,mBAKJ,aAAalU,G,mDACtB,MAAMiT,EAAgBhV,KAAKT,SAASyV,cACpC,IAAIkB,EAEJ,QAAsBlV,IAAlBgU,EAA6B,CAC7B,IAAI9K,EACJA,EAAgBlK,KAAKmW,wBACCnV,IAAlBkJ,IACAA,EAAgBnI,EAAI6F,MAAM,KAAK,IAEnC,MAAMwO,QAAcpB,EAAcqB,SAAStU,OAAKf,EAAWkJ,GAE3D,QAAclJ,IAAVoV,EACAF,EAAM,CACFI,YAAaF,EAAMG,YACnBC,SAAUJ,EAAM7R,UAEjB,CACH,MAAM3E,QAAcI,KAAKyW,YAAY1U,GAErCmU,EAAM,CACFI,YAAa1W,EAAMmC,IACnByU,eAAgB5W,EAAM8W,QAGrB1B,EAAc2B,WAAW,CAC1BC,kBAA2C,OAAxB5W,KAAKkV,eAA0BlV,KAAKkV,eAAevU,WAAaoB,EACnFmI,cAAeA,EACf2M,WAAY9U,EACZwU,YAAaL,EAAII,YACjB/R,WAAY2R,EAAIM,gBAGrB,CACH,MAAM5W,QAAcI,KAAKyW,YAAY1U,GAErCmU,EAAM,CACFI,YAAa1W,EAAMmC,IACnByU,eAAgB5W,EAAM8W,QAK9B,OADA1W,KAAK8W,gBAAgB/U,EAAKmU,EAAIM,SAAUN,EAAII,aACrCJ,KAKE,YACTnU,EACA6S,G,yDAEA,MAAMmC,EAAkB/W,KAAKgX,mBAAmBjV,EAAK6S,GAC/CqC,EAAkBtC,EAAkBC,GAE1C,IAAKmC,EAAiB,CAClB,IAAIrB,EAGJ,MAAMV,EAAgBhV,KAAKT,SAASyV,cACpC,QAAsBhU,IAAlBgU,EAA6B,CAC7B,IAEI9K,EAFA0M,EAAuC,QAAtB,EAAG5W,KAAKkV,sBAAc,eAAEvU,WAK7C,GAFAuJ,EAAgBlK,KAAKmW,wBAECnV,IAAlBkJ,GAA8D,IAA/BlK,KAAKmV,iBAAiBtS,KAAY,CACjE,MAAMqU,EAASlX,KAAKmV,iBAAiB/I,SAAS+K,OACzCD,EAAOjT,OAERiG,EAAgBgN,EAAO/S,MAAMxD,WAAWiH,MAAM,KAAK,IAI3D,QAA0B5G,IAAtB4V,GAAkE,IAA/B5W,KAAKmV,iBAAiBtS,KAAY,CACrE,MAAMqU,EAASlX,KAAKmV,iBAAiB/I,SAAS+K,OACzCD,EAAOjT,OAER2S,EAAoBM,EAAO/S,MAAMxD,YAIzC,QAAsBK,IAAlBkJ,QAAqDlJ,IAAtB4V,EAAiC,CAChE,MAAMR,QAAcpB,EAAcqB,SAAStU,EAAKkV,EAAiB/M,GACjE,QAAclJ,IAAVoV,EACAV,EAAUU,EAAM7R,SACb,CACH,MAAM3E,QAAcI,KAAKyW,YAAY1U,EAAKkV,GAC1CvB,QAAgB9V,EAAMwX,cACjBpC,EAAc2B,WAAW,CAC1BC,kBAAmBA,EACnB1M,cAAeA,EACf2M,WAAY9U,EACZsV,aAAcJ,EACdV,YAAa3W,EAAMmC,IACnBwC,KAAMmR,MAMtB,QAAgB1U,IAAZ0U,EAAuB,CACvB,MAAM9V,QAAcI,KAAKyW,YAAY1U,EAAKkV,GAC1CvB,QAAgB9V,EAAMwX,cAG1B,MAAO,CAAE1B,UAAS3C,kBAAmB,GAGzC,MAAMuE,GACDP,EAAgBnB,SAASC,SAAS0B,cAAgBR,EAAgBnB,SAASC,SAAS0B,cAAgB,GACrGR,EAAgBS,aAEpB,GAAIxX,KAAKqV,UAAUjR,OAAS,EAAG,CACHpE,KAAKqV,UAAUrV,KAAKqV,UAAUjR,OAAS,GAC3CkT,kBAAoBA,EAAkB,IAEtDtX,KAAKqV,UAAY,IAIrBrV,KAAKoV,gBACLpV,KAAKoV,eAAeI,QAAQ,2EAGhC,MAAMiC,EAAU,IAAIC,SAChB,CAACC,EAASC,KAEN5X,KAAKoV,eAAiB,IAAIrO,EACtBhF,EACA6S,EACA0C,EACAP,EAAgBnB,SAASjV,YACzB,CAAC+U,EAAkC3C,IAC/B4E,EAAQ,CAAEjC,UAAS3C,wBACtBrO,GAAUkT,EAAOlT,QAS9B,OAHA1E,KAAKqV,UAAUxQ,KAAK,CAAE1E,WAAY4B,EAAKuT,iBAAkBV,EAAW0C,gBAAiBA,IAChFtX,KAAK6X,aAAad,EAAgBnB,SAAUmB,EAAgBS,cAAc,GAExEC,KAGJ,kBAAkB1V,EAAa6S,EAAsBtJ,EAAewM,GACvE,MAAMC,EAAW/X,KAAKqV,UAAU2C,WAC3BlY,GAAYA,EAAQK,aAAe4B,GAAOyS,EAAkB1U,EAAQwV,iBAAkBV,KAGvFmD,GAAY,IACZ/X,KAAKqV,UAAYrV,KAAKqV,UAAUhM,MAAM0O,GACtC/X,KAAKqV,UAAU,GAAG4C,aAAe,CAAE3M,QAAOwM,YAC1C9X,KAAKiW,kBAIN,+BAA+BiC,GAClC,GAA8B,IAA1BlY,KAAKqV,UAAUjR,SAAiBpE,KAAKqV,UAAU,GAAG4C,aAClD,OAGJ,MAAME,EAAyBnY,KAAKqV,UAAU,GAAG4C,aAC1BE,EAAuB7M,MAAQ6M,EAAuBL,SAExDI,EAAmB,KAIpClY,KAAKqV,UAAYrV,KAAKqV,UAAUhM,MAAM,GACtCrJ,KAAKiW,kBAIN,aAAalU,EAAa6S,GAEzB5U,KAAKoV,gBACLpV,KAAKoV,eAAejV,aAAe4B,GACnCyS,EAAkBxU,KAAKoV,eAAeE,iBAAkBV,KAExD5U,KAAKoV,eAAeG,eAAUvU,EAAW,GACzChB,KAAKoV,eAAiB,MAIjB,U,mDACLpV,KAAKoV,iBACLpV,KAAKoV,eAAeI,QAAQ,qCAC5BxV,KAAKoV,eAAiB,MAG1BpV,KAAKkV,eAAiB,KACtBlV,KAAKmV,iBAAiBnS,QACtBhD,KAAKqV,UAAY,QAEmBrU,IAAhChB,KAAKT,SAASyV,sBACRhV,KAAKT,SAASyV,cAAclS,iBAGhC9C,KAAKiV,OAAOnS,aAGd,iBACJ,IAAK9C,KAAKoV,eACN,OAGJ,MAAM2B,EAAkB/W,KAAKgX,mBACzBhX,KAAKoV,eAAejV,WACpBH,KAAKoV,eAAeE,kBAEpByB,GACK/W,KAAK6X,aAAad,EAAgBnB,SAAUmB,EAAgBS,cAAc,GAsC/E,mBACJzV,EACA6S,GAEA,IAAK,MAAMgB,KAAY5V,KAAKmV,iBAAiB/I,SAAU,CACnD,MAAMoL,EAAe5B,EAASwC,gBAAgBrW,EAAK6S,GACnD,GAAI4C,GAAgB,EAChB,MAAO,CAAE5B,SAAUA,EAAU4B,aAAcA,IAOzC,aAAa5B,EAAoB4B,EAAsBa,G,yDACjE,MAAM/Q,EAAsB,GACtBgR,EAAmB1C,EAASC,SAASvO,SACrCiR,EAAiD,QAAlC,EAAG3C,EAASC,SAAS0B,qBAAa,QAAI,EAC3D,IAAIiB,EAA+B,KAE/B9X,EAAW4L,KAAKmM,IAAI,EAAGzY,KAAKqV,UAAUjR,OAAS,GAEnD,MAAM8F,EAAgBlK,KAAKmW,mBAE3B,IACI,IAAInP,EAAIwQ,EACRxQ,EAAIsR,EAAiBlU,QAAUkD,EAASlD,OAASpE,KAAKT,SAASuV,sBAC7D9N,EACJ,CACE,MAAMlH,EAAU8V,EAASC,SAASvO,SAASN,GAErCjF,EAAM6T,EAAS8C,sBAAsB5Y,EAAQ6Y,KAC7C/D,EAAuB9U,EAAQ8Y,UAC/BpY,EAAKR,KAAK6Y,aAAajD,EAAU2C,EAAkBvR,GAEzDM,EAASzC,KAAK,CACVrE,GAAIA,EACJuB,IAAKA,EACLmI,mBAAiClJ,IAAlBkJ,EAA8BA,EAAgB0L,EAASpO,cACtEoP,kBAA2C,OAAxB5W,KAAKkV,eAA0BlV,KAAKkV,eAAevU,WAAaiV,EAASjV,WAC5F0S,SAAUuC,EAASvC,SACnBE,UAAWgF,EAAkBvR,GAAGgD,WAChClJ,MAAO6T,EAAkBC,GACzBlU,SAAUA,MAEV2X,IAAwBG,IACxBA,EAAgBhY,GAMxB,GAFAR,KAAKiV,OAAO9D,KAAK7J,EAAUsO,EAASpO,eAEhCgR,EAAe,CACf,MAAM1Y,QAAgBE,KAAKiV,OAAO1H,WAAWiL,GAIzC1Y,GAEAE,KAAK2L,gBAAgB7L,OAKzB,aAAa8V,EAAoB0B,GACrC,MAAO,GAAG1B,EAASpO,iBAAiB8P,IAGhC,mBACJ,MAAMwB,EACF9Y,KAAKT,SAASwV,SAA4C,IAAjC/U,KAAKT,SAASwV,QAAQ3Q,OAAepE,KAAKT,SAASwV,aAAU/T,EAC1F,YAAwBA,IAApB8X,EACOA,EAGoB,OAAxB9Y,KAAKkV,eAA0BlV,KAAKkV,eAAevU,WAAWiH,MAAM,KAAK,QAAK5G,EAGjF,iBAAiB+X,GACrB,MAAM7O,EAAgBlK,KAAKmW,mBAE3B,GAAInW,KAAKkV,gBAAkBlV,KAAKkV,eAAeW,SAASC,WAAa5L,EACjE,IAAK,IAAIlD,EAAI,EAAGA,EAAIhH,KAAKkV,eAAeW,SAASC,UAAU1R,SAAU4C,EAAG,CAKpE,GAJY,IAAIgS,IACZhZ,KAAKkV,eAAeW,SAASC,UAAU9O,GAAG2R,IAC1C3Y,KAAKkV,eAAe1Q,aACtBwF,aACU+O,EACR,MAAO,CAAEvR,cAAe,GAAG0C,MAAkBlD,IAAKgP,OAAO,EAAM7I,MAAOnG,GAKlF,MAAO,CACHQ,cAAe0C,UAAiB6O,EAAYnR,MAAM,KAAK,GACvDoO,OAAO,EACP7I,OAAQ,GAIF,YACVpL,EACAjB,G,mDAEA,MAAMF,EAAU,IAAIC,QAEhBC,GACAF,EAAQG,OAAO,QAASD,GAG5B,MAAMmY,EAAejZ,KAAKJ,MAAMmC,EAAK,CAAEnB,YAUvC,OARAqY,EAAazX,OAAOC,QAQbwX,MAIf,MAAM,EAIF,YAA4BtY,EAA6B6D,EAA8BqR,GAA3D,KAAAlV,aAA6B,KAAA6D,cAA8B,KAAAqR,WAHhF,KAAArO,cAAgB,GAKhB,gBAAgBzF,EAAa6S,GAChC,IAAK,IAAI5N,EAAI,EAAGA,EAAIhH,KAAK6V,SAASvO,SAASlD,SAAU4C,EAAG,CACpD,MAAMlH,EAAUE,KAAK6V,SAASvO,SAASN,GAGvC,GAAIjF,IAFe/B,KAAK0Y,sBAAsB5Y,EAAQ6Y,MAE5BnE,EAAkB1U,EAAQ8Y,UAAWhE,GAC3D,OAAO5N,EAIf,OAAQ,EAGL,sBAAsB7G,GACzB,OAAO,IAAI6Y,IAAI7Y,EAAYH,KAAKwE,aAAawF,YAIrD,MAAMjD,EACF,YACa5G,EACAmV,EACAgC,EACA4B,EACA3D,EACAC,GALA,KAAArV,aACA,KAAAmV,mBACA,KAAAgC,kBACA,KAAA4B,qBACA,KAAA3D,YACA,KAAAC,WC/dV,MAAM,EA0BT,YAAmB2D,GAzBX,KAAAC,UAAW,EAEZ,KAAAC,MAAqB,CACxBC,OAAQ,EACRC,MAAO,EACPC,SAAS,EACTC,MAAO,EACPC,WAAY,EACZC,WAAY,EACZC,QAAS,CACLtO,MAAO,EACPuJ,IAAK,EACLgF,MAAO,GAEXC,QAAS,CACLxO,MAAO,EACPuJ,IAAK,GAETkF,UAAW,CACPzO,MAAO,EACPuJ,IAAK,EACLgF,MAAO,IAKX7Z,KAAKmZ,eAAiBA,EAGb,KACT9E,EACA2F,EACAC,G,mDAIA,GAFA,EAAYC,0BAA0Bla,KAAKqZ,OAErChF,EAA0C8F,KAC5C,IACI,MAAMjD,QAAelX,KAAKmZ,eAAeiB,aAAa/F,EAAQtS,KAC9D/B,KAAKoZ,UAAW,EAChBpZ,KAAKqa,gBAAgBnD,EAAQ7C,EAAS4F,GACxC,MAAOK,GACLta,KAAK0E,MAAM4V,EAAGjG,EAAS4F,QAExB,GAAM5F,EAA0CkG,KAAM,CACzD,MAAM,OAAEtF,GAAWjV,KAAKmZ,eAClBvE,EAAYR,EAAaC,GAEzBmG,EAAa1a,GACRA,EAAQiC,MAAQsS,EAAQtS,KAAOjC,EAAQgB,QAAU6T,EAAkBC,GAI9E,IAAI6F,EAA0CpJ,aAAY,KACtD,EAAY6I,0BAA0Bla,KAAKqZ,SAC5C,KAEH,MAAMqB,EAAsB,CAAC5a,EAAkB+C,KACtC2X,EAAU1a,KAEfE,KAAKqZ,MAAME,MAAQ1W,IAEvBoS,EAAOhW,GAAG,IAAOkU,YAAauH,GAE9B,MAAMC,EAAiB,CAACC,EAAgB9a,EAAkBsG,KACjDoU,EAAU1a,KAEfE,KAAKqZ,MAAMC,QAAUlT,IAGnB2F,EAAqB,CAAC4G,EAAwB7S,KAC3C2a,GAA0B,SAAX9H,GAAsB6H,EAAU1a,KAEpDsS,cAAcqI,GACdA,OAAczZ,EAEd,EAAYkZ,0BAA0Bla,KAAKqZ,OAE3CpE,EAAOhW,GAAG,IAAO4T,qBAAsB8H,KAG3C1F,EAAOhW,GAAG,IAAO2T,iBAAkB7G,GAGnC,IACI,MAAMmL,QAAelX,KAAKmZ,eAAe0B,YAAYxG,EAAQtS,IAAK6S,IAC5D,QAAEc,GAAYwB,EAChBxB,IACA1V,KAAKoZ,UAAW,EAChBtQ,YAAW,IAAM9I,KAAK8a,eAAepF,EAASrB,EAAS4F,IAAY,IAGzE,MAAOK,GACLxR,YAAW,IAAM9I,KAAK0E,MAAM4V,EAAGjG,EAAS4F,IAAY,G,QAGpD7H,cAAcqI,GACdxF,EAAO8F,IAAI,IAAOnI,iBAAkB7G,GACpCkJ,EAAO8F,IAAI,IAAO5H,YAAauH,GAC/BzF,EAAO8F,IAAI,IAAOlI,qBAAsB8H,SAO5CK,QAAQC,KAAK,uBAAwB5G,MAItC,MAAMA,EAAwB4F,GACjC,GAAIja,KAAKoZ,SAAU,OAEnBpZ,KAAKmZ,eAAe+B,aAAa7G,EAAQtS,IAAKqS,EAAaC,IAC3DrU,KAAKqZ,MAAMG,SAAU,EAErB,MAAM2B,EAAUlB,aAAS,EAATA,EAAWkB,QACvBA,GACAA,EAAQnb,KAAKqZ,MAAOhF,OAASrT,GAI7B,gBACJoa,EACA/G,EACA4F,GAEA,MAAMvX,EAAMoC,YAAYpC,MAExB1C,KAAKqZ,MAAMO,QAAQ/E,IAAMnS,EACzB1C,KAAKqZ,MAAMC,OAAS8B,EAAI5E,SAASpS,OACjCpE,KAAKqZ,MAAME,MAAQ6B,EAAI5E,SAASpS,OAEhC6V,EAAU1E,UACN,CACIxT,IAAKqZ,EAAI9E,YACT/R,KAAM6W,EAAI5E,UAEdxW,KAAKqZ,MACLhF,OACArT,GAIA,eACJ0U,EACArB,EACA4F,GAEA,MAAMvX,EAAMoC,YAAYpC,MAExB1C,KAAKqZ,MAAMO,QAAQ/E,IAAMnS,EACzB1C,KAAKqZ,MAAMC,OAAS5D,EAAQtU,WAC5BpB,KAAKqZ,MAAME,MAAQ7D,EAAQtU,WAEvB6Y,EAAUoB,YACVpB,EAAUoB,WAAWrb,KAAKqZ,MAAOhF,EAASqB,OAAS1U,GAGvDiZ,EAAU1E,UACN,CACIxT,IAAKsS,EAAQtS,IACbwC,KAAMmR,GAEV1V,KAAKqZ,MACLhF,OACArT,GAIA,MACJ0D,EACA2P,EACA4F,GAEAA,EAAUzE,QAAQ9Q,EAAO2P,OAASrT,GAG9B,iCAAkCqY,GACtC,MAAM/N,EAAQxG,YAAYpC,MAC1B2W,EAAMO,QAAQtO,MAAQA,EACtB+N,EAAMO,QAAQC,MAAQvO,GC/KvB,MAAM,UAAe,eAQxB,YAAmB/L,EAAyC,IACxDH,QAEAY,KAAKiV,OAAS,IAAI,IAAa1V,EAAS0V,QACxCjV,KAAKmZ,eAAiB,IAAI,EAAenZ,KAAKiV,OAAQ1V,GAEtDgI,OAAOE,KAAK,KACP6T,KAAKC,GAAa,IAAOA,KACzBxY,SAAS7D,GAAUc,KAAKiV,OAAOhW,GAAGC,GAAO,IAAII,IAAoBU,KAAKX,KAAKH,KAAUI,OAfvF,qBACH,OAAO,IAAayU,cAiBjB,oB,MACH,MAAMyH,EAASxb,KACf,OAAO,QAMH,cAKA,KAAAmR,KAAO,CACHkD,EACA1D,EACAsJ,IACC,4CACDja,KAAKqU,QAAUA,EACfrU,KAAKia,UAAYA,EACjBja,KAAKyb,KAAKtK,KAAKkD,EAAS1D,EAAQsJ,MAIpC,KAAA5X,MAAQ,KACArC,KAAKqU,SACLrU,KAAKyb,KAAKpZ,MAAMrC,KAAKqU,QAASrU,KAAKia,YAI3C,KAAAnX,QAAU,KACF9C,KAAKqU,SACLrU,KAAKyb,KAAKpZ,MAAMrC,KAAKqU,UAI7B,KAAAqH,kBAAoB,OA3BhB1b,KAAKyb,KAAO,IAAI,EAAYD,EAAOrC,gBACnCnZ,KAAKqZ,MAAQrZ,KAAKyb,KAAKpC,SA4BpBsC,UAAY,IACRH,E,EAKN,U,yDACHxb,KAAKmZ,eAAerW,aAGvB,cAIH,MAAO,CACHwE,SAAUtH,KAAKmZ,eAAelH,cAC9BgD,OAAQjV,KAAKiV,OAAOhD,eAIrB,aACH,MAAO,CACHgD,OAAQjV,KAAKiV,OAAO/C,cAIrB,kBAAkBnQ,EAAa6S,EAAsBtJ,EAAewM,GACvE9X,KAAKmZ,eAAeyC,kBAAkB7Z,EAAK6S,EAAWtJ,EAAOwM,GAG1D,+BAA+BI,GAClClY,KAAKmZ,eAAe0C,+BAA+B3D,ICjGpD,MAAM4D,EAAU,QAchB,SAASC,EAAgBC,GACxBA,GAAUA,EAAOrL,QAAUqL,EAAOrL,OAAOsE,QAAoD,mBAAnC+G,EAAOrL,OAAOsE,OAAO0G,WAC/EM,EAAgBD,EAAQA,EAAOrL,OAAOsE,OAAO0G,aAI9C,SAASO,EAAiBF,GAC7BA,EAAO/c,GAAG,QAAQ,KACd,MAAMkd,EAAWH,EAAOI,KAAKC,qBACzBF,EAASG,OAASH,EAASG,KAAKC,qBAChCJ,EAASG,KAAKC,oBAAqB,EACnCR,EAAgBC,EAAOI,KAAKC,qBAAqBC,UAKtD,SAASE,EAA0BR,GACtCA,EAAO/c,GAAG,SAAS,KAAK,MAAC,OAAA8c,EAAmC,QAApB,EAACC,EAAOR,OAAOiB,aAAK,QAAIT,EAAOR,OAAOkB,QAG3E,SAASC,EAA8BX,GAC1CA,EAAOY,OAAM,KACT,MAAMC,EAAUb,EAAOc,MAAMC,SAEzBF,GACAA,EAAQG,aACRH,EAAQG,YAAY/H,QAC4B,mBAAzC4H,EAAQG,YAAY/H,OAAO0G,WAElCM,EAAgBD,EAAOc,MAAOD,EAAQG,YAAY/H,OAAO0G,gBAK9D,SAASsB,IACGjc,MAAXkc,SAA8Clc,MAAtBkc,QAAQC,YAIpCD,QAAQC,WAAWC,QAAQ,oBAAoB,CAACC,EAAoBZ,KAC5DA,EAAM9L,QAAU8L,EAAM9L,OAAOsE,QAAmD,mBAAlCwH,EAAM9L,OAAOsE,OAAO0G,WAClEM,EAAgBQ,EAAOA,EAAM9L,OAAOsE,OAAO0G,gBAKhD,SAAS2B,EAAyBC,GAGrCA,EAAaC,iBAAiB,kBAAmBte,IAC7C,MAAMwd,EAAMa,EAAaE,UACzB,GAAIf,GAAOA,EAAI/L,QAAU+L,EAAI/L,OAAOsE,QAAiD,mBAAhCyH,EAAI/L,OAAOsE,OAAO0G,UAA0B,CAC7F,MAAMH,EAAiBkB,EAAI/L,OAAOsE,OAAO0G,YAEzC,GAAIzc,EAAMqF,MAAQrF,EAAMqF,KAAKH,OAAS,EAAG,CACrC,MAAMmW,EAAOrb,EAAMqF,KAAK,GAAGgW,KACrB3F,EACwB,IAA1B2F,EAAK3F,UAAUxQ,YACTpD,EACA,CAAEkF,OAAQqU,EAAK3F,UAAU,GAAIxQ,OAAQmW,EAAK3F,UAAU,GAAK2F,EAAK3F,UAAU,IAClF4G,EAAOI,kBAAkBrB,EAAKxY,IAAK6S,EAAW2F,EAAKjP,MAAOiP,EAAKzC,eAI3EyF,EAAaC,iBAAiB,iBAAiB,IAAY,4CACvD,MAAMd,EAAMa,EAAaE,UACzB,GAAIf,GAAOA,EAAI/L,QAAU+L,EAAI/L,OAAOsE,QAAiD,mBAAhCyH,EAAI/L,OAAOsE,OAAO0G,UAA0B,CAC7F,MAAMH,EAAiBkB,EAAI/L,OAAOsE,OAAO0G,kBACnCH,EAAO1Y,gBAGrBya,EAAaC,iBAAiB,YAAate,IACvC,MAAMwd,EAAMa,EAAaE,UACzB,GAAIf,GAAOA,EAAI/L,QAAU+L,EAAI/L,OAAOsE,QAAiD,mBAAhCyH,EAAI/L,OAAOsE,OAAO0G,gBAChD3a,IAAf9B,EAAMqF,MAA6C,uBAAvBrF,EAAMqF,KAAK0O,QAAkC,CAClDyJ,EAAI/L,OAAOsE,OAAO0G,YAClCE,+BAA+Ba,EAAIgB,MAAMC,iBAMzD,SAASC,EAAa5B,EAAagB,GACtC,MAAMa,EAAMxM,aAAY,KAChB2K,EAAOU,KAAOV,EAAOU,IAAI/L,SACzByB,cAAcyL,GACdtW,OAAOuW,OAAO9B,EAAOU,IAAI/L,OAAQqM,GACjCjB,EAAgBC,EAAOU,QAE5B,KAGP,SAAST,EAAgBD,EAAaR,GAClCQ,EAAO/c,GAAG,kBAAkB,CAAC8e,EAAgBxZ,KACzC,MAAMgW,EAAOhW,EAAKgW,KACZ3F,EACwB,IAA1B2F,EAAK3F,UAAUxQ,YACTpD,EACA,CAAEkF,OAAQqU,EAAK3F,UAAU,GAAIxQ,OAAQmW,EAAK3F,UAAU,GAAK2F,EAAK3F,UAAU,IAClF4G,EAAOI,kBAAkBrB,EAAKxY,IAAK6S,EAAW2F,EAAKjP,MAAOiP,EAAKzC,aAEnEkE,EAAO/c,GAAG,iBAAiB,IAAY,kDAC7Buc,EAAO1Y,eAEjBkZ,EAAO/c,GAAG,YAAY,CAAC8e,EAAgBC,KACnC,GAA0B,uBAAtBA,EAAU/K,QAAkC,CAC5C,MAAMgL,OAAqCjd,IAAjBgb,EAAO0B,MAC3B1B,EAAOkC,IACPlC,EAAO0B,MACTO,GACAzC,EAAOK,+BAA+BoC,EAAiBN","file":"1.chunk.js?v=4893","sourcesContent":["/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { EventEmitter } from \"events\";\n\nexport type Segment = {\n    readonly id: string;\n    readonly url: string;\n    readonly masterSwarmId: string;\n    readonly masterManifestUri: string;\n    readonly streamId: string | undefined;\n    readonly sequence: string;\n    readonly range: string | undefined;\n    readonly priority: number;\n    data?: ArrayBuffer;\n    downloadBandwidth?: number;\n    requestUrl?: string;\n    responseUrl?: string;\n};\n\nexport enum Events {\n    /**\n     * Emitted when segment has been downloaded.\n     * Args: segment\n     */\n    SegmentLoaded = \"segment_loaded\",\n\n    /**\n     * Emitted when an error occurred while loading the segment.\n     * Args: segment, error\n     */\n    SegmentError = \"segment_error\",\n\n\n    /**\n     * Emitter when we the segment size is known\n     * Args: segment, size\n     */\n    SegmentSize = \"segment_size\",\n\n    /**\n     * Emitted for each segment that does not hit into a new segments queue when the load() method is called.\n     * Args: segment\n     */\n    SegmentAbort = \"segment_abort\",\n\n\n    /**\n     * Emitted when the loader started to load a segment\n     * Args: method, segment\n     */\n    SegmentStartLoad = \"segment_start_load\",\n\n    /**\n     * Emitted when a peer is connected.\n     * Args: peer\n     */\n    PeerConnect = \"peer_connect\",\n\n    /**\n     * Emitted when a peer is disconnected.\n     * Args: peerId\n     */\n    PeerClose = \"peer_close\",\n\n    /**\n     * Emitted when a segment piece has been downloaded.\n     * Args: method (can be \"http\" or \"p2p\" only), bytes\n     */\n    PieceBytesDownloaded = \"piece_bytes_downloaded\",\n\n    /**\n     * Emitted when a segment piece has been uploaded.\n     * Args: method (can be \"p2p\" only), bytes\n     */\n    PieceBytesUploaded = \"piece_bytes_uploaded\",\n}\n\nexport interface LoaderInterface extends EventEmitter {\n    on: ((eventName: string, listener: (...params: unknown[]) => void) => this) &\n        ((eventName: Events.SegmentStartLoad, listener: (method: \"http\" | \"p2p\", segment: Segment) => void) => this) &\n        ((eventName: Events.SegmentSize, listener: (segment: Segment, size: number) => void) => this) &\n        ((eventName: Events.PieceBytesDownloaded | Events.PieceBytesUploaded, listener: (method: \"http\" | \"p2p\", segment: Segment, bytes: number, peerId?: string) => void) => this) &\n        ((eventName: Events.SegmentLoaded, listener: (segment: Segment) => void) => this) &\n        ((eventName: Events.SegmentError, listener: (segment: Segment, error: unknown) => void) => this) &\n        ((eventName: Events.SegmentAbort, listener: (segment: Segment) => void) => this);\n    load: (segments: Segment[], streamSwarmId: string) => void;\n    getSegment: (id: string) => Promise<Segment | undefined>;\n    getSettings: () => unknown;\n    getDetails: () => unknown;\n    getBandwidthEstimate: () => number;\n    destroy: () => Promise<void>;\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { EventEmitter } from \"events\";\n\nexport class STEEmitter<T extends string | symbol> extends EventEmitter {\n    public on = (event: T, listener: (...args: any[]) => void): this => super.on(event, listener);\n    public emit = (event: T, ...args: any[]): boolean => super.emit(event, ...args);\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Debug from \"debug\";\n\nimport { STEEmitter } from \"./stringly-typed-event-emitter\";\nimport { Segment } from \"./loader-interface\";\nimport { SegmentValidatorCallback /*, XhrSetupCallback */, SegmentUrlBuilder } from \"./hybrid-loader\";\n\nclass FilteredEmitter extends STEEmitter<\n    \"segment-start-load\" | \"segment-loaded\" | \"segment-error\" | \"segment-size\" | \"bytes-downloaded\"\n> { }\n\nexport class HttpMediaManager extends FilteredEmitter {\n    private fetchRequests = new Map<string, { request?: Promise<Response>; fetchAbort: AbortController, segment: Segment, initialPriority: number, segmentUrl: string }>();\n    private failedSegments = new Map<string, number>();\n    private debug = Debug(\"p2pml:http-media-manager\");\n    private fetch: typeof fetch = (...args) => fetch(...args);\n\n    public constructor(\n        readonly settings: {\n            httpFailedSegmentTimeout: number;\n            httpUseRanges: boolean;\n            requiredSegmentsPriority: number;\n            segmentValidator?: SegmentValidatorCallback;\n            /* xhrSetup?: XhrSetupCallback; */\n            segmentUrlBuilder?: SegmentUrlBuilder;\n            localTransport?: typeof fetch;\n        }\n    ) {\n        super();\n\n        if (settings.localTransport) {\n            this.fetch = settings.localTransport;\n        }\n    }\n\n    public download = (segment: Segment, downloadedPieces?: ArrayBuffer[]): void => {\n        if (this.isDownloading(segment)) {\n            return;\n        }\n\n        this.cleanTimedOutFailedSegments();\n\n        this.emit(\"segment-start-load\", segment);\n\n        const segmentUrl = this.buildSegmentUrl(segment);\n\n        const fetchAbort = new AbortController();\n\n        this.fetchRequests.set(segment.id, { fetchAbort, segment, initialPriority: segment.priority, segmentUrl });\n\n        this.debug(\"http segment download\", segmentUrl);\n\n        segment.requestUrl = segmentUrl;\n\n        const headers = new Headers();\n\n        if (segment.range) {\n            headers.append('Range', segment.range);\n        } else if (downloadedPieces !== undefined && this.settings.httpUseRanges) {\n            let bytesDownloaded = 0;\n            for (const piece of downloadedPieces) {\n                bytesDownloaded += piece.byteLength;\n            }\n\n            headers.append(\"Range\", `bytes=${bytesDownloaded}-`);\n\n            this.debug(\"continue download from\", bytesDownloaded);\n        } else {\n            downloadedPieces = undefined;\n        }\n\n        const signal = fetchAbort.signal;\n\n        const fetchRequest = this.fetch(segmentUrl, { headers, signal });\n\n        void this.setupFetchEvents(fetchRequest, segment, downloadedPieces)\n            .catch((err: Error) => {\n                /**\n                 * Handling all fetch errors here\n                 */\n\n                if (err.name === \"AbortError\") {\n                    /**\n                     * This may happen on video seeking\n                     * or halted video playing. In most\n                     * cases it is normal. For more info\n                     * look AbortController...\n                     */\n                    this.debug(\"Segment loading was aborted by user\", segment);\n                    return;\n                }\n\n                if (err.message === \"network error\") {\n                    this.debug(\"Segment loading is unavailable. No internet\", segment);\n\n                    const netError = Error(\"NETWORK_ERROR\");\n\n                    this.segmentFailure(segment, netError, segment.url);\n                    return;\n                }\n\n                if (err.message === \"Failed to fetch\") {\n                    /**\n                     * This error might occur in next cases:\n                     *   - Network error\n                     *   - Response with erroneous CORS headers\n                     *   - Unsupported protocol, e.g. HTTPS\n                     *   - Wrong request method\n                     */\n\n                    this.debug(\"Segment fetch failed\", segment);\n\n                    const fetchError = Error(\"FETCH_FAILED\");\n\n                    this.segmentFailure(segment, fetchError, segment.url);\n                    return;\n                }\n            });\n\n        /* if (this.settings.xhrSetup) {\n            this.settings.xhrSetup(xhr, segmentUrl);\n        } */\n\n        this.fetchRequests.set(segment.id, { request: fetchRequest, fetchAbort, segment, initialPriority: segment.priority, segmentUrl });\n\n        return;\n    };\n\n    public updatePriority = (segment: Segment): void => {\n        const request = this.fetchRequests.get(segment.id);\n\n        if (!request) {\n            throw new Error(\"Cannot update priority of not downloaded segment \" + segment.id);\n        }\n\n        // Segment is now in high priority\n        // If the segment URL changed, retry the request with the new URL\n        if (\n            segment.priority <= this.settings.requiredSegmentsPriority &&\n            request.initialPriority > this.settings.requiredSegmentsPriority &&\n            request.segmentUrl !== this.buildSegmentUrl(segment)\n        ) {\n            this.debug(\"aborting http segment abort because the segment is now in a high priority\", segment.id);\n            this.abort(segment)\n            this.download(segment)\n        }\n\n    }\n\n    public abort = (segment: Segment): void => {\n        const request = this.fetchRequests.get(segment.id);\n\n        if (request) {\n            request.fetchAbort.abort();\n            this.fetchRequests.delete(segment.id);\n            this.debug(\"http segment abort\", segment.id);\n        }\n    };\n\n    public isDownloading = (segment: Segment): boolean => {\n        return this.fetchRequests.has(segment.id);\n    };\n\n    public isFailed = (segment: Segment): boolean => {\n        const time = this.failedSegments.get(segment.id);\n        return time !== undefined && time > this.now();\n    };\n\n    public getActiveDownloads = (): ReadonlyMap<string, { segment: Segment }> => {\n        return this.fetchRequests;\n    };\n\n    public getActiveDownloadsCount = (): number => {\n        return this.fetchRequests.size;\n    };\n\n    public destroy = (): void => {\n        this.fetchRequests.forEach((request) => request.fetchAbort.abort());\n        this.fetchRequests.clear();\n    };\n\n    private setupFetchEvents = async (fetch: Promise<Response>, segment: Segment, downloadedPieces?: ArrayBuffer[]) => {\n        const fetchResponse = await fetch as Response & { body: ReadableStream };\n\n        const dataReader = fetchResponse.body.getReader();\n\n        const contentLengthStr = fetchResponse.headers.get(\"Content-Length\") as string;\n\n        const contentLength = Number.parseFloat(contentLengthStr);\n\n        const dataBytes: Uint8Array = new Uint8Array(contentLength);\n\n        let nextChunkPos = 0;\n\n        if (Array.isArray(downloadedPieces) && fetchResponse.status === 206) {\n            for (const piece of downloadedPieces) {\n                const pieceBytes = new Uint8Array(piece);\n\n                dataBytes.set(pieceBytes, nextChunkPos);\n\n                nextChunkPos = piece.byteLength;\n            }\n        }\n\n        let read;\n\n        while (!(read = await dataReader.read()).done) {\n            const chunkBytes = read.value;\n\n            dataBytes.set(chunkBytes, nextChunkPos);\n\n            nextChunkPos += chunkBytes.length;\n\n            /** Events emitters */\n\n            this.emit(\"bytes-downloaded\", segment, chunkBytes.length);\n\n            if (contentLength) {\n                this.emit(\"segment-size\", segment, contentLength);\n            }\n        }\n\n        if (fetchResponse.status < 200 || fetchResponse.status >= 300) {\n            const err = Error(`Segment failure with HTTP code ${fetchResponse.status}`);\n            this.segmentFailure(segment, err, fetchResponse.url);\n            return;\n        }\n\n        await this.segmentDownloadFinished(segment, dataBytes.buffer, fetchResponse);\n    };\n\n    private segmentDownloadFinished = async (segment: Segment, data: ArrayBuffer, fetchResponse: Response) => {\n        segment.responseUrl = fetchResponse.url;\n\n        if (this.settings.segmentValidator) {\n            try {\n                await this.settings.segmentValidator({ ...segment, data: data }, \"http\");\n            } catch (error) {\n                this.debug(\"segment validator failed\", error);\n                this.segmentFailure(segment, error, fetchResponse.url);\n                return;\n            }\n        }\n\n        this.fetchRequests.delete(segment.id);\n        this.emit(\"segment-loaded\", segment, data);\n    };\n\n    private segmentFailure = (segment: Segment, error: Error, responseUrl: string) => {\n        segment.responseUrl = responseUrl;\n\n        this.fetchRequests.delete(segment.id);\n        this.failedSegments.set(segment.id, this.now() + this.settings.httpFailedSegmentTimeout);\n        this.emit(\"segment-error\", segment, error);\n    };\n\n    private cleanTimedOutFailedSegments = () => {\n        const now = this.now();\n        const candidates: string[] = [];\n\n        this.failedSegments.forEach((time, id) => {\n            if (time < now) {\n                candidates.push(id);\n            }\n        });\n\n        candidates.forEach((id) => this.failedSegments.delete(id));\n    };\n\n    private buildSegmentUrl (segment: Segment) {\n        if (this.settings.segmentUrlBuilder) {\n            return this.settings.segmentUrlBuilder(segment);\n        }\n\n        return segment.url;\n    }\n\n    private now = () => performance.now();\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\nimport Debug from \"debug\";\nimport { Buffer } from \"buffer\";\n\nimport { STEEmitter } from \"./stringly-typed-event-emitter\";\n\nenum MediaPeerCommands {\n    SegmentData,\n    SegmentAbsent,\n    SegmentsMap,\n    SegmentRequest,\n    CancelSegmentRequest,\n}\n\ntype MediaPeerCommand =\n    | {\n          c:\n              | MediaPeerCommands.SegmentAbsent\n              | MediaPeerCommands.SegmentRequest\n              | MediaPeerCommands.CancelSegmentRequest;\n          i: string;\n      }\n    | {\n          c: MediaPeerCommands.SegmentsMap;\n          m: { [key: string]: [string, number[]] };\n      }\n    | {\n          c: MediaPeerCommands.SegmentData;\n          i: string;\n          s: number;\n      };\n\nexport enum MediaPeerSegmentStatus {\n    Loaded,\n    LoadingByHttp,\n}\n\nclass DownloadingSegment {\n    public bytesDownloaded = 0;\n    public pieces: ArrayBuffer[] = [];\n    constructor(readonly id: string, readonly size: number) {}\n}\n\nexport class MediaPeer extends STEEmitter<\n    | \"connect\"\n    | \"close\"\n    | \"data-updated\"\n    | \"segment-start-load\"\n    | \"segment-request\"\n    | \"segment-absent\"\n    | \"segment-loaded\"\n    | \"segment-error\"\n    | \"segment-timeout\"\n    | \"segment-size\"\n    | \"bytes-downloaded\"\n    | \"bytes-uploaded\"\n> {\n    public id: string;\n    public remoteAddress = \"\";\n    private downloadingSegmentId: string | null = null;\n    private downloadingSegment: DownloadingSegment | null = null;\n    private segmentsMap = new Map<string, MediaPeerSegmentStatus>();\n    private debug = Debug(\"p2pml:media-peer\");\n    private timer: ReturnType<typeof setTimeout> | null = null;\n\n    constructor(\n        // eslint-disable-next-line\n        readonly peer: any,\n        readonly settings: {\n            p2pSegmentDownloadTimeout: number;\n            webRtcMaxMessageSize: number;\n        }\n    ) {\n        super();\n\n        this.peer.on(\"connect\", this.onPeerConnect);\n        this.peer.on(\"close\", this.onPeerClose);\n        this.peer.on(\"error\", this.onPeerError);\n        this.peer.on(\"data\", this.onPeerData);\n\n        this.id = peer.id;\n    }\n\n    private onPeerConnect = () => {\n        this.debug(\"peer connect\", this.id, this);\n        this.remoteAddress = this.peer.remoteAddress;\n        this.emit(\"connect\", this);\n    };\n\n    private onPeerClose = () => {\n        this.debug(\"peer close\", this.id, this);\n        this.terminateSegmentRequest();\n        this.emit(\"close\", this);\n    };\n\n    private onPeerError = (error: unknown) => {\n        this.debug(\"peer error\", this.id, error, this);\n    };\n\n    private receiveSegmentPiece = (data: ArrayBuffer): void => {\n        if (!this.downloadingSegment) {\n            // The segment was not requested or canceled\n            this.debug(\"peer segment not requested\", this.id, this);\n            return;\n        }\n\n        this.downloadingSegment.bytesDownloaded += data.byteLength;\n        this.downloadingSegment.pieces.push(data);\n\n        const segmentId = this.downloadingSegment.id;\n        this.emit(\"bytes-downloaded\", this, segmentId, data.byteLength);\n\n        if (this.downloadingSegment.bytesDownloaded === this.downloadingSegment.size) {\n            const segmentData = new Uint8Array(this.downloadingSegment.size);\n            let offset = 0;\n            for (const piece of this.downloadingSegment.pieces) {\n                segmentData.set(new Uint8Array(piece), offset);\n                offset += piece.byteLength;\n            }\n\n            this.debug(\"peer segment download done\", this.id, segmentId, this);\n            this.terminateSegmentRequest();\n            this.emit(\"segment-loaded\", this, segmentId, segmentData.buffer);\n        } else if (this.downloadingSegment.bytesDownloaded > this.downloadingSegment.size) {\n            this.debug(\"peer segment download bytes mismatch\", this.id, segmentId, this);\n            this.terminateSegmentRequest();\n            this.emit(\"segment-error\", this, segmentId, \"Too many bytes received for segment\");\n        }\n    };\n\n    private getJsonCommand = (data: ArrayBuffer) => {\n        const bytes = new Uint8Array(data);\n\n        // Serialized JSON string check by first, second and last characters: '{\" .... }'\n        if (bytes[0] === 123 && bytes[1] === 34 && bytes[data.byteLength - 1] === 125) {\n            try {\n                return JSON.parse(new TextDecoder().decode(data)) as Record<string, unknown>;\n            } catch {\n                return null;\n            }\n        }\n\n        return null;\n    };\n\n    private onPeerData = (data: ArrayBuffer) => {\n        const command = this.getJsonCommand(data);\n\n        if (command === null) {\n            this.receiveSegmentPiece(data);\n            return;\n        }\n\n        if (this.downloadingSegment) {\n            this.debug(\"peer segment download is interrupted by a command\", this.id, this);\n\n            const segmentId = this.downloadingSegment.id;\n            this.terminateSegmentRequest();\n            this.emit(\"segment-error\", this, segmentId, \"Segment download is interrupted by a command\");\n            return;\n        }\n\n        this.debug(\"peer receive command\", this.id, command, this);\n\n        switch (command.c) {\n            case MediaPeerCommands.SegmentsMap:\n                this.segmentsMap = this.createSegmentsMap(command.m);\n                this.emit(\"data-updated\");\n                break;\n\n            case MediaPeerCommands.SegmentRequest:\n                this.emit(\"segment-request\", this, command.i);\n                break;\n\n            case MediaPeerCommands.SegmentData:\n                if (\n                    this.downloadingSegmentId &&\n                    this.downloadingSegmentId === command.i &&\n                    typeof command.s === \"number\" &&\n                    command.s >= 0\n                ) {\n                    this.downloadingSegment = new DownloadingSegment(command.i, command.s);\n                    this.emit(\"segment-start-load\", this.downloadingSegment.id)\n                    this.emit(\"segment-size\", this.downloadingSegment.id, this.downloadingSegment.size)\n                    this.cancelResponseTimeoutTimer();\n                }\n                break;\n\n            case MediaPeerCommands.SegmentAbsent:\n                if (this.downloadingSegmentId && this.downloadingSegmentId === command.i) {\n                    this.terminateSegmentRequest();\n                    this.segmentsMap.delete(command.i);\n                    this.emit(\"segment-absent\", this, command.i);\n                }\n                break;\n\n            case MediaPeerCommands.CancelSegmentRequest:\n                // TODO: peer stop sending buffer\n                break;\n\n            default:\n                break;\n        }\n    };\n\n    private createSegmentsMap = (segments: unknown) => {\n        if (!(segments instanceof Object)) {\n            return new Map<string, MediaPeerSegmentStatus>();\n        }\n\n        const segmentsMap = new Map<string, MediaPeerSegmentStatus>();\n\n        for (const streamSwarmId of Object.keys(segments)) {\n            const swarmData = (segments as Record<string, unknown>)[streamSwarmId];\n            if (\n                !(swarmData instanceof Array) ||\n                swarmData.length !== 2 ||\n                typeof swarmData[0] !== \"string\" ||\n                !(swarmData[1] instanceof Array)\n            ) {\n                return new Map<string, MediaPeerSegmentStatus>();\n            }\n\n            const segmentsIds = swarmData[0].split(\"|\");\n            const segmentsStatuses = swarmData[1] as MediaPeerSegmentStatus[];\n\n            if (segmentsIds.length !== segmentsStatuses.length) {\n                return new Map<string, MediaPeerSegmentStatus>();\n            }\n\n            for (let i = 0; i < segmentsIds.length; i++) {\n                const segmentStatus = segmentsStatuses[i];\n                if (typeof segmentStatus !== \"number\" || MediaPeerSegmentStatus[segmentStatus] === undefined) {\n                    return new Map<string, MediaPeerSegmentStatus>();\n                }\n\n                segmentsMap.set(`${streamSwarmId}+${segmentsIds[i]}`, segmentStatus);\n            }\n        }\n\n        return segmentsMap;\n    };\n\n    private sendCommand = (command: MediaPeerCommand): void => {\n        this.debug(\"peer send command\", this.id, command, this);\n        this.peer.write(JSON.stringify(command));\n    };\n\n    public destroy = (): void => {\n        this.debug(\"peer destroy\", this.id, this);\n        this.terminateSegmentRequest();\n        this.peer.destroy();\n    };\n\n    public getDownloadingSegmentId = (): string | null => {\n        return this.downloadingSegmentId;\n    };\n\n    public getSegmentsMap = (): Map<string, MediaPeerSegmentStatus> => {\n        return this.segmentsMap;\n    };\n\n    public sendSegmentsMap = (segmentsMap: { [key: string]: [string, number[]] }): void => {\n        this.sendCommand({ c: MediaPeerCommands.SegmentsMap, m: segmentsMap });\n    };\n\n    public sendSegmentData = (segmentId: string, data: ArrayBuffer): void => {\n        this.sendCommand({\n            c: MediaPeerCommands.SegmentData,\n            i: segmentId,\n            s: data.byteLength,\n        });\n\n        let bytesLeft = data.byteLength;\n        while (bytesLeft > 0) {\n            const bytesToSend =\n                bytesLeft >= this.settings.webRtcMaxMessageSize ? this.settings.webRtcMaxMessageSize : bytesLeft;\n            const buffer = Buffer.from(data, data.byteLength - bytesLeft, bytesToSend);\n\n            this.peer.write(buffer);\n            bytesLeft -= bytesToSend;\n        }\n\n        this.emit(\"bytes-uploaded\", this, segmentId, data.byteLength);\n    };\n\n    public sendSegmentAbsent = (segmentId: string): void => {\n        this.sendCommand({ c: MediaPeerCommands.SegmentAbsent, i: segmentId });\n    };\n\n    public requestSegment = (segmentId: string): void => {\n        if (this.downloadingSegmentId) {\n            throw new Error(\"A segment is already downloading: \" + this.downloadingSegmentId);\n        }\n\n        this.sendCommand({ c: MediaPeerCommands.SegmentRequest, i: segmentId });\n        this.downloadingSegmentId = segmentId;\n        this.runResponseTimeoutTimer();\n    };\n\n    public cancelSegmentRequest = (): ArrayBuffer[] | undefined => {\n        let downloadingSegment: ArrayBuffer[] | undefined;\n\n        if (this.downloadingSegmentId) {\n            const segmentId = this.downloadingSegmentId;\n            downloadingSegment = this.downloadingSegment ? this.downloadingSegment.pieces : undefined;\n            this.terminateSegmentRequest();\n            this.sendCommand({ c: MediaPeerCommands.CancelSegmentRequest, i: segmentId });\n        }\n\n        return downloadingSegment;\n    };\n\n    private runResponseTimeoutTimer = (): void => {\n        this.timer = setTimeout(() => {\n            this.timer = null;\n            if (!this.downloadingSegmentId) {\n                return;\n            }\n            const segmentId = this.downloadingSegmentId;\n            this.cancelSegmentRequest();\n            this.emit(\"segment-timeout\", this, segmentId); // TODO: send peer not responding event\n        }, this.settings.p2pSegmentDownloadTimeout);\n    };\n\n    private cancelResponseTimeoutTimer = (): void => {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    };\n\n    private terminateSegmentRequest = () => {\n        this.downloadingSegmentId = null;\n        this.downloadingSegment = null;\n        this.cancelResponseTimeoutTimer();\n    };\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\nimport Debug from \"debug\";\nimport Client from \"bittorrent-tracker/client\";\nimport { Buffer } from \"buffer\";\nimport sha1 from \"sha.js/sha1\";\n\nimport { STEEmitter } from \"./stringly-typed-event-emitter\";\nimport { Segment } from \"./loader-interface\";\nimport { MediaPeer, MediaPeerSegmentStatus } from \"./media-peer\";\nimport { SegmentsStorage, SegmentValidatorCallback } from \"./hybrid-loader\";\n\nconst PEER_PROTOCOL_VERSION = 2;\nconst PEER_ID_VERSION_STRING = '0.6.2'.replace(/\\d*./g, (v) => `0${parseInt(v, 10) % 100}`.slice(-2)).slice(0, 4);\nconst PEER_ID_VERSION_PREFIX = `-WW${PEER_ID_VERSION_STRING}-`; // Using WebTorrent client ID in order to not be banned by websocket trackers\n\nclass PeerSegmentRequest {\n    constructor(readonly peerId: string, readonly segment: Segment) {}\n}\n\nfunction generatePeerId(): ArrayBuffer {\n    const PEER_ID_SYMBOLS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const PEER_ID_LENGTH = 20;\n\n    let peerId = PEER_ID_VERSION_PREFIX;\n\n    for (let i = 0; i < PEER_ID_LENGTH - PEER_ID_VERSION_PREFIX.length; i++) {\n        peerId += PEER_ID_SYMBOLS.charAt(Math.floor(Math.random() * PEER_ID_SYMBOLS.length));\n    }\n\n    return new TextEncoder().encode(peerId).buffer;\n}\n\nexport class P2PMediaManager extends STEEmitter<\n    | \"peer-connected\"\n    | \"peer-closed\"\n    | \"peer-data-updated\"\n    | \"segment-start-load\"\n    | \"segment-loaded\"\n    | \"segment-error\"\n    | \"segment-size\"\n    | \"bytes-downloaded\"\n    | \"bytes-uploaded\"\n    | \"tracker-update\"\n> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    private trackerClient: any = null;\n    private peers = new Map<string, MediaPeer>();\n    private peerCandidates = new Map<string, MediaPeer[]>();\n    private peerSegmentRequests = new Map<string, PeerSegmentRequest>();\n    private streamSwarmId: string | null = null;\n    private readonly peerId: ArrayBuffer;\n    private debug = Debug(\"p2pml:p2p-media-manager\");\n    private pendingTrackerClient: {\n        isDestroyed: boolean;\n    } | null = null;\n    private masterSwarmId?: string;\n\n    public constructor(\n        private segmentsStorage: SegmentsStorage,\n        private settings: {\n            useP2P: boolean;\n            trackerAnnounce: string[];\n            p2pSegmentDownloadTimeout: number;\n            segmentValidator?: SegmentValidatorCallback;\n            webRtcMaxMessageSize: number;\n            rtcConfig?: RTCConfiguration;\n            peerRequestsPerAnnounce: number;\n        }\n    ) {\n        super();\n\n        this.peerId = settings.useP2P ? generatePeerId() : new ArrayBuffer(0);\n\n        if (this.debug.enabled) {\n            this.debug(\"peer ID\", this.getPeerId(), new TextDecoder().decode(this.peerId));\n        }\n    }\n\n    public getPeers = (): Map<string, MediaPeer> => {\n        return this.peers;\n    };\n\n    public getPeerId = (): string => {\n        return Buffer.from(this.peerId).toString(\"hex\");\n    };\n\n    public setStreamSwarmId = (streamSwarmId: string, masterSwarmId: string): void => {\n        if (this.streamSwarmId === streamSwarmId) {\n            return;\n        }\n\n        this.destroy(true);\n\n        this.streamSwarmId = streamSwarmId;\n        this.masterSwarmId = masterSwarmId;\n        this.debug(\"stream swarm ID\", this.streamSwarmId);\n\n        this.pendingTrackerClient = {\n            isDestroyed: false,\n        };\n\n        const pendingTrackerClient = this.pendingTrackerClient;\n\n        // TODO: native browser 'crypto.subtle' implementation doesn't work in Chrome in insecure pages\n        // TODO: Edge doesn't support SHA-1. Change to SHA-256 once Edge support is required.\n        // const infoHash = await crypto.subtle.digest(\"SHA-1\", new TextEncoder().encode(PEER_PROTOCOL_VERSION + this.streamSwarmId));\n\n        const infoHash = new sha1().update(`${PEER_PROTOCOL_VERSION}${this.streamSwarmId}`).digest();\n\n        // destroy may be called while waiting for the hash to be calculated\n        if (!pendingTrackerClient.isDestroyed) {\n            this.pendingTrackerClient = null;\n            this.createClient(infoHash);\n        } else if (this.trackerClient !== null) {\n            this.trackerClient.destroy();\n            this.trackerClient = null;\n        }\n    };\n\n    private createClient = (infoHash: ArrayBuffer): void => {\n        if (!this.settings.useP2P) {\n            return;\n        }\n\n        const clientOptions = {\n            infoHash: Buffer.from(infoHash, 0, 20),\n            peerId: Buffer.from(this.peerId, 0, 20),\n            announce: this.settings.trackerAnnounce,\n            rtcConfig: this.settings.rtcConfig,\n            port: 6881, // a dummy value allows running in Node.js environment\n            getAnnounceOpts: () => {\n                return { numwant: this.settings.peerRequestsPerAnnounce };\n            },\n        };\n\n        let oldTrackerClient = this.trackerClient;\n\n        this.trackerClient = new Client(clientOptions);\n        this.trackerClient.on(\"error\", this.onTrackerError);\n        this.trackerClient.on(\"warning\", this.onTrackerWarning);\n        this.trackerClient.on(\"update\", this.onTrackerUpdate);\n        this.trackerClient.on(\"peer\", this.onTrackerPeer);\n\n        this.trackerClient.start();\n\n        if (oldTrackerClient !== null) {\n            oldTrackerClient.destroy();\n            oldTrackerClient = null;\n        }\n    };\n\n    private onTrackerError = (error: unknown) => {\n        this.debug(\"tracker error\", error);\n    };\n\n    private onTrackerWarning = (warning: unknown) => {\n        this.debug(\"tracker warning\", warning);\n    };\n\n    private onTrackerUpdate = (data: unknown): void => {\n        this.debug(\"tracker update\", data);\n        this.emit(\"tracker-update\", data);\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    private onTrackerPeer = (trackerPeer: any): void => {\n        this.debug(\"tracker peer\", trackerPeer.id, trackerPeer);\n\n        if (this.peers.has(trackerPeer.id)) {\n            this.debug(\"tracker peer already connected\", trackerPeer.id, trackerPeer);\n            trackerPeer.destroy();\n            return;\n        }\n\n        const peer = new MediaPeer(trackerPeer, this.settings);\n\n        peer.on(\"connect\", this.onPeerConnect);\n        peer.on(\"close\", this.onPeerClose);\n        peer.on(\"data-updated\", this.onPeerDataUpdated);\n        peer.on(\"segment-request\", this.onSegmentRequest);\n        peer.on(\"segment-loaded\", this.onSegmentLoaded);\n        peer.on(\"segment-absent\", this.onSegmentAbsent);\n        peer.on(\"segment-error\", this.onSegmentError);\n        peer.on(\"segment-size\", this.onSegmentSize);\n        peer.on(\"segment-start-load\", this.onSegmentStartLoad);\n        peer.on(\"segment-timeout\", this.onSegmentTimeout);\n        peer.on(\"bytes-downloaded\", this.onPieceBytesDownloaded);\n        peer.on(\"bytes-uploaded\", this.onPieceBytesUploaded);\n\n        let peerCandidatesById = this.peerCandidates.get(peer.id);\n\n        if (!peerCandidatesById) {\n            peerCandidatesById = [];\n            this.peerCandidates.set(peer.id, peerCandidatesById);\n        }\n\n        peerCandidatesById.push(peer);\n    };\n\n    public download = (segment: Segment): boolean => {\n        if (this.isDownloading(segment)) {\n            return false;\n        }\n\n        const candidates: MediaPeer[] = [];\n\n        for (const peer of this.peers.values()) {\n            if (\n                peer.getDownloadingSegmentId() === null &&\n                peer.getSegmentsMap().get(segment.id) === MediaPeerSegmentStatus.Loaded\n            ) {\n                candidates.push(peer);\n            }\n        }\n\n        if (candidates.length === 0) {\n            return false;\n        }\n\n        const peer = candidates[Math.floor(Math.random() * candidates.length)];\n        peer.requestSegment(segment.id);\n        this.peerSegmentRequests.set(segment.id, new PeerSegmentRequest(peer.id, segment));\n        return true;\n    };\n\n    public abort = (segment: Segment): ArrayBuffer[] | undefined => {\n        let downloadingSegment: ArrayBuffer[] | undefined;\n        const peerSegmentRequest = this.peerSegmentRequests.get(segment.id);\n        if (peerSegmentRequest) {\n            const peer = this.peers.get(peerSegmentRequest.peerId);\n            if (peer) {\n                downloadingSegment = peer.cancelSegmentRequest();\n            }\n            this.peerSegmentRequests.delete(segment.id);\n        }\n        return downloadingSegment;\n    };\n\n    public isDownloading = (segment: Segment): boolean => {\n        return this.peerSegmentRequests.has(segment.id);\n    };\n\n    public getActiveDownloadsCount = (): number => {\n        return this.peerSegmentRequests.size;\n    };\n\n    public destroy = (swarmChange = false): void => {\n        this.streamSwarmId = null;\n\n        if (this.trackerClient) {\n            this.trackerClient.stop();\n            if (swarmChange) {\n                // Don't destroy trackerClient to reuse its WebSocket connection to the tracker server\n                this.trackerClient.removeAllListeners(\"error\");\n                this.trackerClient.removeAllListeners(\"warning\");\n                this.trackerClient.removeAllListeners(\"update\");\n                this.trackerClient.removeAllListeners(\"peer\");\n            } else {\n                this.trackerClient.destroy();\n                this.trackerClient = null;\n            }\n        }\n\n        if (this.pendingTrackerClient) {\n            this.pendingTrackerClient.isDestroyed = true;\n            this.pendingTrackerClient = null;\n        }\n\n        this.peers.forEach((peer) => peer.destroy());\n        this.peers.clear();\n\n        this.peerSegmentRequests.clear();\n\n        for (const peerCandidateById of this.peerCandidates.values()) {\n            for (const peerCandidate of peerCandidateById) {\n                peerCandidate.destroy();\n            }\n        }\n        this.peerCandidates.clear();\n    };\n\n    public sendSegmentsMapToAll = (segmentsMap: { [key: string]: [string, number[]] }): void => {\n        this.peers.forEach((peer) => peer.sendSegmentsMap(segmentsMap));\n    };\n\n    public sendSegmentsMap = (peerId: string, segmentsMap: { [key: string]: [string, number[]] }): void => {\n        const peer = this.peers.get(peerId);\n        if (peer) {\n            peer.sendSegmentsMap(segmentsMap);\n        }\n    };\n\n    public getOverallSegmentsMap = (): Map<string, MediaPeerSegmentStatus> => {\n        const overallSegmentsMap = new Map<string, MediaPeerSegmentStatus>();\n\n        for (const peer of this.peers.values()) {\n            for (const [segmentId, segmentStatus] of peer.getSegmentsMap()) {\n                if (segmentStatus === MediaPeerSegmentStatus.Loaded) {\n                    overallSegmentsMap.set(segmentId, MediaPeerSegmentStatus.Loaded);\n                } else if (!overallSegmentsMap.get(segmentId)) {\n                    overallSegmentsMap.set(segmentId, MediaPeerSegmentStatus.LoadingByHttp);\n                }\n            }\n        }\n\n        return overallSegmentsMap;\n    };\n\n    private onPieceBytesDownloaded = (peer: MediaPeer, segmentId: string, bytes: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        if (peerSegmentRequest) {\n            this.emit(\"bytes-downloaded\", peerSegmentRequest.segment, bytes, peer.id);\n        }\n    };\n\n    private onPieceBytesUploaded = (peer: MediaPeer, segmentId: string, bytes: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        \n        this.emit(\"bytes-uploaded\", peerSegmentRequest ? peerSegmentRequest.segment : null, bytes, peer.id);\n      \n    };\n\n    private onPeerConnect = (peer: MediaPeer) => {\n        const connectedPeer = this.peers.get(peer.id);\n\n        if (connectedPeer) {\n            this.debug(\"tracker peer already connected (in peer connect)\", peer.id, peer);\n            peer.destroy();\n            return;\n        }\n\n        // First peer with the ID connected\n        this.peers.set(peer.id, peer);\n\n        // Destroy all other peer candidates\n        const peerCandidatesById = this.peerCandidates.get(peer.id);\n        if (peerCandidatesById) {\n            for (const peerCandidate of peerCandidatesById) {\n                if (peerCandidate !== peer) {\n                    peerCandidate.destroy();\n                }\n            }\n\n            this.peerCandidates.delete(peer.id);\n        }\n\n        this.emit(\"peer-connected\", { id: peer.id, remoteAddress: peer.remoteAddress });\n    };\n\n    private onPeerClose = (peer: MediaPeer) => {\n        if (this.peers.get(peer.id) !== peer) {\n            // Try to delete the peer candidate\n\n            const peerCandidatesById = this.peerCandidates.get(peer.id);\n            if (!peerCandidatesById) {\n                return;\n            }\n\n            const index = peerCandidatesById.indexOf(peer);\n            if (index !== -1) {\n                peerCandidatesById.splice(index, 1);\n            }\n\n            if (peerCandidatesById.length === 0) {\n                this.peerCandidates.delete(peer.id);\n            }\n\n            return;\n        }\n\n        for (const [key, value] of this.peerSegmentRequests) {\n            if (value.peerId === peer.id) {\n                this.peerSegmentRequests.delete(key);\n            }\n        }\n\n        this.peers.delete(peer.id);\n        this.emit(\"peer-data-updated\");\n        this.emit(\"peer-closed\", peer.id);\n    };\n\n    private onPeerDataUpdated = () => {\n        this.emit(\"peer-data-updated\");\n    };\n\n    private onSegmentRequest = async (peer: MediaPeer, segmentId: string) => {\n        if (this.masterSwarmId === undefined) {\n            return;\n        }\n\n        const segment = await this.segmentsStorage.getSegment(segmentId, this.masterSwarmId);\n        if (segment && segment.data) {\n            peer.sendSegmentData(segmentId, segment.data);\n        } else {\n            peer.sendSegmentAbsent(segmentId);\n        }\n    };\n\n    private onSegmentLoaded = async (peer: MediaPeer, segmentId: string, data: ArrayBuffer) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n        if (!peerSegmentRequest) {\n            return;\n        }\n\n        const segment = peerSegmentRequest.segment;\n\n        if (this.settings.segmentValidator) {\n            try {\n                await this.settings.segmentValidator({ ...segment, data: data }, \"p2p\", peer.id);\n            } catch (error) {\n                this.debug(\"segment validator failed\", error);\n                this.peerSegmentRequests.delete(segmentId);\n                this.emit(\"segment-error\", segment, error, peer.id);\n                this.onPeerClose(peer);\n                return;\n            }\n        }\n\n        this.peerSegmentRequests.delete(segmentId);\n        this.emit(\"segment-loaded\", segment, data, peer.id);\n    };\n\n    private onSegmentAbsent = (peer: MediaPeer, segmentId: string) => {\n        this.peerSegmentRequests.delete(segmentId);\n        this.emit(\"peer-data-updated\");\n    };\n\n    private onSegmentError = (peer: MediaPeer, segmentId: string, description: string) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n        if (peerSegmentRequest) {\n            this.peerSegmentRequests.delete(segmentId);\n            this.emit(\"segment-error\", peerSegmentRequest.segment, description, peer.id);\n        }\n    };\n\n    private onSegmentSize = (segmentId: string, size: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        if (peerSegmentRequest) {\n            this.emit(\"segment-size\", peerSegmentRequest.segment, size);\n        }\n    };\n\n    private onSegmentStartLoad = (segmentId: string, size: number) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n\n        if (peerSegmentRequest) {\n            this.emit(\"segment-start-load\", peerSegmentRequest.segment, size);\n        }\n    };\n\n    private onSegmentTimeout = (peer: MediaPeer, segmentId: string) => {\n        const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n        if (peerSegmentRequest) {\n            this.peerSegmentRequests.delete(segmentId);\n            peer.destroy();\n            if (this.peers.delete(peerSegmentRequest.peerId)) {\n                this.emit(\"peer-data-updated\");\n            }\n        }\n    };\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Debug from \"debug\";\n\nconst debug = Debug(\"p2pml:bandwidth-approximator\");\n\nconst SMOOTH_INTERVAL = 2 * 1000;\nconst MEASURE_INTERVAL = 40 * 1000;\n\nclass NumberWithTime {\n    constructor(readonly value: number, readonly timeStamp: number) {}\n}\n\nexport class BandwidthApproximator {\n    private lastBytes: NumberWithTime[] = [];\n    private currentBytesSum = 0;\n    private lastBandwidth: NumberWithTime[] = [];\n\n    public addBytes = (bytes: number, timeStamp: number): void => {\n        debug(\"Add %d bytes.\", bytes)\n\n        this.lastBytes.push(new NumberWithTime(bytes, timeStamp));\n        this.currentBytesSum += bytes;\n\n        while (timeStamp - this.lastBytes[0].timeStamp > SMOOTH_INTERVAL) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.currentBytesSum -= this.lastBytes.shift()!.value;\n        }\n\n        const interval = Math.min(SMOOTH_INTERVAL, timeStamp);\n        this.lastBandwidth.push(new NumberWithTime(this.currentBytesSum / interval, timeStamp));\n    };\n\n    // in bytes per millisecond\n    public getBandwidth = (timeStamp: number): number => {\n        while (this.lastBandwidth.length !== 0 && timeStamp - this.lastBandwidth[0].timeStamp > MEASURE_INTERVAL) {\n            this.lastBandwidth.shift();\n        }\n\n        let maxBandwidth = 0;\n        for (const bandwidth of this.lastBandwidth) {\n            if (bandwidth.value > maxBandwidth) {\n                maxBandwidth = bandwidth.value;\n            }\n        }\n\n        debug(\"Max bandwidth: %d.\", maxBandwidth)\n\n        return maxBandwidth;\n    };\n\n    public getSmoothInterval = (): number => {\n        return SMOOTH_INTERVAL;\n    };\n\n    public getMeasureInterval = (): number => {\n        return MEASURE_INTERVAL;\n    };\n}\n","/**\n * Copyright 2019 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Segment } from \"./loader-interface\";\nimport { SegmentsStorage } from \"./hybrid-loader\";\n\nexport class SegmentsMemoryStorage implements SegmentsStorage {\n    private cache = new Map<string, { segment: Segment; lastAccessed: number }>();\n\n    constructor(\n        private settings: {\n            cachedSegmentExpiration: number;\n            cachedSegmentsCount: number;\n        }\n    ) {}\n\n    public storeSegment = async (segment: Segment): Promise<void> => {\n        this.cache.set(segment.id, { segment, lastAccessed: performance.now() });\n    };\n\n    public getSegmentsMap = async (): Promise<Map<string, { segment: Segment }>> => {\n        return this.cache;\n    };\n\n    public getSegment = async (id: string): Promise<Segment | undefined> => {\n        const cacheItem = this.cache.get(id);\n\n        if (cacheItem === undefined) {\n            return undefined;\n        }\n\n        cacheItem.lastAccessed = performance.now();\n        return cacheItem.segment;\n    };\n\n    public hasSegment = async (id: string): Promise<boolean> => {\n        return this.cache.has(id);\n    };\n\n    public clean = async (masterSwarmId: string, lockedSegmentsFilter?: (id: string) => boolean): Promise<boolean> => {\n        const segmentsToDelete: string[] = [];\n        const remainingSegments: { segment: Segment; lastAccessed: number }[] = [];\n\n        // Delete old segments\n        const now = performance.now();\n\n        for (const cachedSegment of this.cache.values()) {\n            if (now - cachedSegment.lastAccessed > this.settings.cachedSegmentExpiration) {\n                segmentsToDelete.push(cachedSegment.segment.id);\n            } else {\n                remainingSegments.push(cachedSegment);\n            }\n        }\n\n        // Delete segments over cached count\n        let countOverhead = remainingSegments.length - this.settings.cachedSegmentsCount;\n        if (countOverhead > 0) {\n            remainingSegments.sort((a, b) => a.lastAccessed - b.lastAccessed);\n\n            for (const cachedSegment of remainingSegments) {\n                if (lockedSegmentsFilter === undefined || !lockedSegmentsFilter(cachedSegment.segment.id)) {\n                    segmentsToDelete.push(cachedSegment.segment.id);\n                    countOverhead--;\n                    if (countOverhead === 0) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        segmentsToDelete.forEach((id) => this.cache.delete(id));\n        return segmentsToDelete.length > 0;\n    };\n\n    public destroy = async (): Promise<void> => {\n        this.cache.clear();\n    };\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Debug from \"debug\";\nimport { EventEmitter } from \"events\";\nimport Peer from \"simple-peer\";\n\nimport { LoaderInterface, Events, Segment } from \"./loader-interface\";\nimport { HttpMediaManager } from \"./http-media-manager\";\nimport { P2PMediaManager } from \"./p2p-media-manager\";\nimport { MediaPeerSegmentStatus } from \"./media-peer\";\nimport { BandwidthApproximator } from \"./bandwidth-approximator\";\nimport { SegmentsMemoryStorage } from \"./segments-memory-storage\";\n/*\nconst defaultSettings: HybridLoaderSettings = {\n    cachedSegmentExpiration: 5 * 60 * 1000,\n    cachedSegmentsCount: 30,\n\n    useP2P: true,\n    consumeOnly: false,\n\n    requiredSegmentsPriority: 1,\n\n    simultaneousHttpDownloads: 2,\n    httpDownloadProbability: 0.1,\n    httpDownloadProbabilityInterval: 1000,\n    httpDownloadProbabilitySkipIfNoPeers: false,\n    httpFailedSegmentTimeout: 10000,\n    httpDownloadMaxPriority: 20,\n    httpDownloadInitialTimeout: 0,\n    httpDownloadInitialTimeoutPerSegment: 4000,\n    httpUseRanges: false,\n\n    simultaneousP2PDownloads: 3,\n    p2pDownloadMaxPriority: 20,\n    p2pSegmentDownloadTimeout: 60000,\n\n    webRtcMaxMessageSize: 64 * 1024 - 1,\n    trackerAnnounce: [\"wss://tracker.novage.com.ua\", \"wss://tracker.openwebtorrent.com\"],\n    peerRequestsPerAnnounce: 10,\n    rtcConfig: (Peer as { config: RTCConfiguration }).config,\n};*/\n\n\nconst defaultSettings: HybridLoaderSettings & { localTransport?: typeof fetch } = {\n    cachedSegmentExpiration: 10 * 60 * 1000,\n    cachedSegmentsCount: 1000,\n\n    useP2P: true,\n    consumeOnly: false,\n\n    requiredSegmentsPriority: 3,\n\n    simultaneousHttpDownloads: 2,\n    httpDownloadProbability: 0.06,\n    httpDownloadProbabilityInterval: 1000,\n    httpDownloadProbabilitySkipIfNoPeers: false,\n    httpFailedSegmentTimeout: 1500,\n    httpDownloadMaxPriority: 20,\n    httpDownloadInitialTimeout: 0,\n    httpDownloadInitialTimeoutPerSegment: 100, ///segment = 4000\n    httpUseRanges: false,\n\n    simultaneousP2PDownloads: 20,\n    p2pDownloadMaxPriority: 50,\n    p2pSegmentDownloadTimeout: 60000,\n\n    webRtcMaxMessageSize: 64 * 1024 - 1,\n    trackerAnnounce: [\"wss://tracker.novage.com.ua\", \"wss://tracker.openwebtorrent.com\"],\n    peerRequestsPerAnnounce: 10,\n    rtcConfig: (Peer as { config: RTCConfiguration }).config,\n};\n\nexport class HybridLoader extends EventEmitter implements LoaderInterface {\n    private readonly debug = Debug(\"p2pml:hybrid-loader\");\n    private readonly debugSegments = Debug(\"p2pml:hybrid-loader-segments\");\n    private readonly httpManager: HttpMediaManager;\n    private readonly p2pManager: P2PMediaManager;\n    private segmentsStorage: SegmentsStorage;\n    private segmentsQueue: Segment[] = [];\n    private readonly bandwidthApproximator = new BandwidthApproximator();\n    private readonly settings: HybridLoaderSettings & { localTransport?: typeof fetch };\n    private httpRandomDownloadInterval: ReturnType<typeof setInterval> | undefined;\n    private httpDownloadInitialTimeoutTimestamp = -Infinity;\n    private masterSwarmId?: string;\n\n    public static isSupported = (): boolean => {\n        return window.RTCPeerConnection.prototype.createDataChannel !== undefined;\n    };\n\n    public constructor(settings: Partial<HybridLoaderSettings & { localTransport?: typeof fetch }> = {}) {\n        super();\n\n        this.settings = { ...defaultSettings, ...settings };\n\n        const { bufferedSegmentsCount } = settings as Record<string, unknown>;\n\n        if (typeof bufferedSegmentsCount === \"number\") {\n            if (settings.p2pDownloadMaxPriority === undefined) {\n                this.settings.p2pDownloadMaxPriority = bufferedSegmentsCount;\n            }\n\n            if (settings.httpDownloadMaxPriority === undefined) {\n                this.settings.p2pDownloadMaxPriority = bufferedSegmentsCount;\n            }\n        }\n\n        this.segmentsStorage =\n            this.settings.segmentsStorage === undefined\n                ? new SegmentsMemoryStorage(this.settings)\n                : this.settings.segmentsStorage;\n\n        this.debug(\"loader settings\", this.settings);\n\n        this.httpManager = this.createHttpManager();\n        this.httpManager.on(\"segment-start-load\", (segment: Segment) => this.onSegmentStartLoad(\"http\", segment));\n        this.httpManager.on(\"segment-loaded\", this.onSegmentLoaded);\n        this.httpManager.on(\"segment-error\", this.onSegmentError);\n        this.httpManager.on(\"segment-size\", this.onSegmentSize);\n        this.httpManager.on(\"bytes-downloaded\", (segment: Segment, bytes: number) => {\n            this.onPieceBytesDownloaded(\"http\", segment, bytes)\n        });\n\n        this.p2pManager = this.createP2PManager();\n        this.p2pManager.on(\"segment-start-load\", (segment: Segment) => this.onSegmentStartLoad(\"p2p\", segment));\n        this.p2pManager.on(\"segment-loaded\", this.onSegmentLoaded);\n        this.p2pManager.on(\"segment-error\", this.onSegmentError);\n        this.p2pManager.on(\"segment-size\", this.onSegmentSize);\n        this.p2pManager.on(\"peer-data-updated\", async () => {\n            if (this.masterSwarmId === undefined) {\n                return;\n            }\n\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n            }\n        });\n        this.p2pManager.on(\"bytes-downloaded\", (segment: Segment, bytes: number, peerId: string) =>\n            this.onPieceBytesDownloaded(\"p2p\", segment, bytes, peerId)\n        );\n        this.p2pManager.on(\"bytes-uploaded\", (segment: Segment, bytes: number, peerId: string) =>\n            this.onPieceBytesUploaded(\"p2p\", segment, bytes, peerId)\n        );\n        this.p2pManager.on(\"peer-connected\", this.onPeerConnect);\n        this.p2pManager.on(\"peer-closed\", this.onPeerClose);\n        this.p2pManager.on(\"tracker-update\", this.onTrackerUpdate);\n    }\n\n    private createHttpManager = () => {\n        return new HttpMediaManager(this.settings);\n    };\n\n    private createP2PManager = () => {\n        return new P2PMediaManager(this.segmentsStorage, this.settings);\n    };\n\n    public load = async (segments: Segment[], streamSwarmId: string): Promise<void> => {\n        if (this.httpRandomDownloadInterval === undefined) {\n            // Do once on first call\n            this.httpRandomDownloadInterval = setInterval(\n                this.downloadRandomSegmentOverHttp,\n                this.settings.httpDownloadProbabilityInterval\n            );\n\n            if (\n                this.settings.httpDownloadInitialTimeout > 0 &&\n                this.settings.httpDownloadInitialTimeoutPerSegment > 0\n            ) {\n                // Initialize initial HTTP download timeout (i.e. download initial segments over P2P)\n                this.debugSegments(\n                    \"enable initial HTTP download timeout\",\n                    this.settings.httpDownloadInitialTimeout,\n                    \"per segment\",\n                    this.settings.httpDownloadInitialTimeoutPerSegment\n                );\n                this.httpDownloadInitialTimeoutTimestamp = this.now();\n                setTimeout(this.processInitialSegmentTimeout, this.settings.httpDownloadInitialTimeoutPerSegment + 100);\n            }\n        }\n\n        if (segments.length > 0) {\n            this.masterSwarmId = segments[0].masterSwarmId;\n        }\n\n        if (this.masterSwarmId !== undefined) {\n            this.p2pManager.setStreamSwarmId(streamSwarmId, this.masterSwarmId);\n        }\n\n        this.debug(\"load segments\");\n\n        let updateSegmentsMap = false;\n\n        // stop all http requests and p2p downloads for segments that are not in the new load\n        for (const segment of this.segmentsQueue) {\n            if (!segments.find((f) => f.url === segment.url)) {\n                this.debug(\"remove segment\", segment.url);\n                if (this.httpManager.isDownloading(segment)) {\n                    updateSegmentsMap = true;\n                    this.httpManager.abort(segment);\n                } else {\n                    this.p2pManager.abort(segment);\n                }\n                this.emit(Events.SegmentAbort, segment);\n            }\n        }\n\n        if (this.debug.enabled) {\n            for (const segment of segments) {\n                if (!this.segmentsQueue.find((f) => f.url === segment.url)) {\n                    this.debug(\"add segment\", segment.url);\n                }\n            }\n        }\n\n        this.segmentsQueue = segments;\n\n        if (this.masterSwarmId === undefined) {\n            return;\n        }\n\n        let storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n        updateSegmentsMap = this.processSegmentsQueue(storageSegments) || updateSegmentsMap;\n\n        if (await this.cleanSegmentsStorage()) {\n            storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n            updateSegmentsMap = true;\n        }\n\n        if (updateSegmentsMap && !this.settings.consumeOnly) {\n            this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n        }\n    };\n\n    public getSegment = async (id: string): Promise<Segment | undefined> => {\n        return this.masterSwarmId === undefined ? undefined : this.segmentsStorage.getSegment(id, this.masterSwarmId);\n    };\n\n    public getSettings = (): HybridLoaderSettings => {\n        return this.settings;\n    };\n\n    public getDetails = (): { peerId: string } => {\n        return {\n            peerId: this.p2pManager.getPeerId(),\n        };\n    };\n\n    public getBandwidthEstimate = (): number => {\n        return this.bandwidthApproximator.getBandwidth(this.now());\n    };\n\n    public destroy = async (): Promise<void> => {\n        if (this.httpRandomDownloadInterval !== undefined) {\n            clearInterval(this.httpRandomDownloadInterval);\n            this.httpRandomDownloadInterval = undefined;\n        }\n\n        this.httpDownloadInitialTimeoutTimestamp = -Infinity;\n\n        this.segmentsQueue = [];\n        this.httpManager.destroy();\n        this.p2pManager.destroy();\n        this.masterSwarmId = undefined;\n        await this.segmentsStorage.destroy();\n    };\n\n    private processInitialSegmentTimeout = async () => {\n        if (this.httpRandomDownloadInterval === undefined) {\n            return; // Instance destroyed\n        }\n\n        if (this.masterSwarmId !== undefined) {\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n            }\n        }\n\n        if (this.httpDownloadInitialTimeoutTimestamp !== -Infinity) {\n            // Set one more timeout for a next segment\n            setTimeout(this.processInitialSegmentTimeout, this.settings.httpDownloadInitialTimeoutPerSegment);\n        }\n    };\n\n    private processSegmentsQueue = (storageSegments: Map<string, { segment: Segment }>) => {\n        this.debugSegments(\n            \"process segments queue. priority\",\n            this.segmentsQueue.length > 0 ? this.segmentsQueue[0].priority : 0\n        );\n\n        if (this.masterSwarmId === undefined || this.segmentsQueue.length === 0) {\n            return false;\n        }\n\n        let updateSegmentsMap = false;\n        let segmentsMap: Map<string, MediaPeerSegmentStatus> | undefined;\n\n        let httpAllowed = true;\n\n        if (this.httpDownloadInitialTimeoutTimestamp !== -Infinity) {\n            let firstNotDownloadePriority: number | undefined;\n\n            for (const segment of this.segmentsQueue) {\n                if (!storageSegments.has(segment.id)) {\n                    firstNotDownloadePriority = segment.priority;\n                    break;\n                }\n            }\n\n            const httpTimeout = this.now() - this.httpDownloadInitialTimeoutTimestamp;\n            httpAllowed =\n                httpTimeout >= this.settings.httpDownloadInitialTimeout ||\n                (firstNotDownloadePriority !== undefined &&\n                    httpTimeout > this.settings.httpDownloadInitialTimeoutPerSegment &&\n                    firstNotDownloadePriority <= 0);\n\n            if (httpAllowed) {\n                this.debugSegments(\"cancel initial HTTP download timeout - timed out\");\n                this.httpDownloadInitialTimeoutTimestamp = -Infinity;\n            }\n        }\n\n        for (let index = 0; index < this.segmentsQueue.length; index++) {\n            const segment = this.segmentsQueue[index];\n\n            if (storageSegments.has(segment.id)) {\n                continue;\n            }\n\n            // Segment priority changed, notify http manager\n            if (this.httpManager.isDownloading(segment)) {\n                this.httpManager.updatePriority(segment);\n                continue;\n            }\n\n            if (\n                segment.priority <= this.settings.requiredSegmentsPriority &&\n                httpAllowed &&\n                !this.httpManager.isFailed(segment)\n            ) {\n                // Download required segments over HTTP\n                if (this.httpManager.getActiveDownloadsCount() >= this.settings.simultaneousHttpDownloads) {\n                    // Not enough HTTP download resources. Abort one of the HTTP downloads.\n                    for (let i = this.segmentsQueue.length - 1; i > index; i--) {\n                        const segmentToAbort = this.segmentsQueue[i];\n                        if (this.httpManager.isDownloading(segmentToAbort)) {\n                            this.debugSegments(\"cancel HTTP download\", segmentToAbort.priority, segmentToAbort.url);\n                            this.httpManager.abort(segmentToAbort);\n                            break;\n                        }\n                    }\n                }\n\n                if (this.httpManager.getActiveDownloadsCount() < this.settings.simultaneousHttpDownloads) {\n                    // Abort P2P download of the required segment if any and force HTTP download\n                    const downloadedPieces = this.p2pManager.abort(segment);\n                    this.httpManager.download(segment, downloadedPieces);\n                    this.debugSegments(\"HTTP download (priority)\", segment.priority, segment.url);\n                    updateSegmentsMap = true;\n                    continue;\n                }\n            }\n\n            if (this.p2pManager.isDownloading(segment)) {\n                continue;\n            }\n\n            if (segment.priority <= this.settings.requiredSegmentsPriority) {\n                // Download required segments over P2P\n                segmentsMap = segmentsMap ? segmentsMap : this.p2pManager.getOverallSegmentsMap();\n\n                if (segmentsMap.get(segment.id) !== MediaPeerSegmentStatus.Loaded) {\n                    continue;\n                }\n\n                if (this.p2pManager.getActiveDownloadsCount() >= this.settings.simultaneousP2PDownloads) {\n                    // Not enough P2P download resources. Abort one of the P2P downloads.\n                    for (let i = this.segmentsQueue.length - 1; i > index; i--) {\n                        const segmentToAbort = this.segmentsQueue[i];\n                        if (this.p2pManager.isDownloading(segmentToAbort)) {\n                            this.debugSegments(\"cancel P2P download\", segmentToAbort.priority, segmentToAbort.url);\n                            this.p2pManager.abort(segmentToAbort);\n                            break;\n                        }\n                    }\n                }\n\n                if (this.p2pManager.getActiveDownloadsCount() < this.settings.simultaneousP2PDownloads) {\n                    if (this.p2pManager.download(segment)) {\n                        this.debugSegments(\"P2P download (priority)\", segment.priority, segment.url);\n                        continue;\n                    }\n                }\n\n                continue;\n            }\n\n            if (\n                this.p2pManager.getActiveDownloadsCount() < this.settings.simultaneousP2PDownloads &&\n                segment.priority <= this.settings.p2pDownloadMaxPriority\n            ) {\n                if (this.p2pManager.download(segment)) {\n                    this.debugSegments(\"P2P download\", segment.priority, segment.url);\n                }\n            }\n        }\n\n        return updateSegmentsMap;\n    };\n\n    private downloadRandomSegmentOverHttp = async () => {\n        if (\n            this.masterSwarmId === undefined ||\n            this.httpRandomDownloadInterval === undefined ||\n            this.httpDownloadInitialTimeoutTimestamp !== -Infinity ||\n            this.httpManager.getActiveDownloadsCount() >= this.settings.simultaneousHttpDownloads ||\n            (this.settings.httpDownloadProbabilitySkipIfNoPeers && this.p2pManager.getPeers().size === 0) ||\n            this.settings.consumeOnly\n        ) {\n            return;\n        }\n\n        const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n        const segmentsMap = this.p2pManager.getOverallSegmentsMap();\n\n        const pendingQueue = this.segmentsQueue.filter(\n            (s) =>\n                !this.p2pManager.isDownloading(s) &&\n                !this.httpManager.isDownloading(s) &&\n                !segmentsMap.has(s.id) &&\n                !this.httpManager.isFailed(s) &&\n                s.priority <= this.settings.httpDownloadMaxPriority &&\n                !storageSegments.has(s.id)\n        );\n\n        if (pendingQueue.length === 0) {\n            return;\n        }\n\n        if (Math.random() > this.settings.httpDownloadProbability * pendingQueue.length) {\n            return;\n        }\n\n        const segment = pendingQueue[Math.floor(Math.random() * pendingQueue.length)];\n        this.debugSegments(\"HTTP download (random)\", segment.priority, segment.url);\n        this.httpManager.download(segment);\n        this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n    };\n\n    private onSegmentStartLoad = (method: \"http\" | \"p2p\", segment: Segment) => {\n        this.emit(Events.SegmentStartLoad, method, segment);\n    };\n\n    private onPieceBytesDownloaded = (method: \"http\" | \"p2p\", segment: Segment, bytes: number, peerId?: string) => {\n        this.bandwidthApproximator.addBytes(bytes, this.now());\n        this.emit(Events.PieceBytesDownloaded, method, segment, bytes, peerId);\n\n    };\n\n    private onPieceBytesUploaded = (method: \"p2p\", segment: Segment, bytes: number, peerId?: string) => {\n        this.emit(Events.PieceBytesUploaded, method, segment, bytes, peerId);\n    };\n\n    private onSegmentLoaded = async (segment: Segment, data: ArrayBuffer, peerId?: string) => {\n        this.debugSegments(\"segment loaded\", segment.id, segment.url);\n\n        if (this.masterSwarmId === undefined) {\n            return;\n        }\n\n        segment.data = data;\n        segment.downloadBandwidth = this.bandwidthApproximator.getBandwidth(this.now());\n\n        await this.segmentsStorage.storeSegment(segment);\n        this.emit(Events.SegmentLoaded, segment, peerId);\n\n        const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n\n        this.processSegmentsQueue(storageSegments);\n        if (!this.settings.consumeOnly) {\n            this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n        }\n    };\n\n    private onSegmentError = async (segment: Segment, details: unknown, peerId?: string) => {\n        this.debugSegments(\"segment error\", segment.id, segment.url, peerId, details);\n        this.emit(Events.SegmentError, segment, details, peerId);\n        if (this.masterSwarmId !== undefined) {\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n            }\n        }\n    };\n\n    private onSegmentSize = async (segment: Segment, size: number) => {\n        this.debugSegments(\"segment size\", segment.id, size);\n        this.emit(Events.SegmentSize, segment, size);\n    };\n\n    private getStreamSwarmId = (segment: Segment) => {\n        return segment.streamId === undefined ? segment.masterSwarmId : `${segment.masterSwarmId}+${segment.streamId}`;\n    };\n\n    private createSegmentsMap = (storageSegments: Map<string, { segment: Segment }>) => {\n        const segmentsMap: { [key: string]: [string, number[]] } = {};\n\n        const addSegmentToMap = (segment: Segment, status: MediaPeerSegmentStatus) => {\n            const streamSwarmId = this.getStreamSwarmId(segment);\n            const segmentId = segment.sequence;\n\n            let segmentsIdsAndStatuses = segmentsMap[streamSwarmId];\n            if (segmentsIdsAndStatuses === undefined) {\n                segmentsIdsAndStatuses = [\"\", []];\n                segmentsMap[streamSwarmId] = segmentsIdsAndStatuses;\n            }\n            const segmentsStatuses = segmentsIdsAndStatuses[1];\n            segmentsIdsAndStatuses[0] += segmentsStatuses.length === 0 ? segmentId : `|${segmentId}`;\n            segmentsStatuses.push(status);\n        };\n\n        for (const storageSegment of storageSegments.values()) {\n            addSegmentToMap(storageSegment.segment, MediaPeerSegmentStatus.Loaded);\n        }\n\n        for (const download of this.httpManager.getActiveDownloads().values()) {\n            addSegmentToMap(download.segment, MediaPeerSegmentStatus.LoadingByHttp);\n        }\n\n        return segmentsMap;\n    };\n\n    private onPeerConnect = async (peer: { id: string }) => {\n        this.emit(Events.PeerConnect, peer);\n        if (!this.settings.consumeOnly && this.masterSwarmId !== undefined) {\n            this.p2pManager.sendSegmentsMap(\n                peer.id,\n                this.createSegmentsMap(await this.segmentsStorage.getSegmentsMap(this.masterSwarmId))\n            );\n        }\n    };\n\n    private onPeerClose = (peerId: string) => {\n        this.emit(Events.PeerClose, peerId);\n    };\n\n    private onTrackerUpdate = async (data: { incomplete?: number }) => {\n        if (\n            this.httpDownloadInitialTimeoutTimestamp !== -Infinity &&\n            data.incomplete !== undefined &&\n            data.incomplete <= 1\n        ) {\n            this.debugSegments(\"cancel initial HTTP download timeout - no peers\");\n\n            this.httpDownloadInitialTimeoutTimestamp = -Infinity;\n\n            if (this.masterSwarmId !== undefined) {\n                const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n\n                if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\n                    this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n                }\n            }\n        }\n    };\n\n    private cleanSegmentsStorage = async (): Promise<boolean> => {\n        if (this.masterSwarmId === undefined) {\n            return false;\n        }\n\n        return this.segmentsStorage.clean(\n            this.masterSwarmId,\n            (id: string) => this.segmentsQueue.find((queueSegment) => queueSegment.id === id) !== undefined\n        );\n    };\n\n    private now = () => {\n        return performance.now();\n    };\n}\n\nexport interface SegmentsStorage {\n    storeSegment: (segment: Segment) => Promise<void>;\n    getSegmentsMap: (masterSwarmId: string) => Promise<Map<string, { segment: Segment }>>;\n    getSegment: (id: string, masterSwarmId: string) => Promise<Segment | undefined>;\n    clean: (masterSwarmId: string, lockedSegmentsFilter?: (id: string) => boolean) => Promise<boolean>;\n    destroy: () => Promise<void>;\n}\n\nexport type SegmentValidatorCallback = (segment: Segment, method: \"http\" | \"p2p\", peerId?: string) => Promise<void>;\n/* export type XhrSetupCallback = (xhr: XMLHttpRequest, url: string) => void; */\nexport type SegmentUrlBuilder = (segment: Segment) => string;\n\nexport type HybridLoaderSettings = {\n    /**\n     * Segment lifetime in cache. The segment is deleted from the cache if the last access time is greater than this value (in milliseconds).\n     */\n    cachedSegmentExpiration: number;\n\n    /**\n     * Max number of segments that can be stored in the cache.\n     */\n    cachedSegmentsCount: number;\n\n    /**\n     * Enable/Disable peers interaction.\n     */\n    useP2P: boolean;\n\n    /**\n     * The peer will not upload segments data to the P2P network but still download from others.\n     */\n    consumeOnly: boolean;\n\n    /**\n     * The maximum priority of the segments to be downloaded (if not available) as quickly as possible (i.e. via HTTP method).\n     */\n    requiredSegmentsPriority: number;\n\n    /**\n     * Max number of simultaneous downloads from HTTP source.\n     */\n    simultaneousHttpDownloads: number;\n\n    /**\n     * Probability of downloading remaining not downloaded segment in the segments queue via HTTP.\n     */\n    httpDownloadProbability: number;\n\n    /**\n     * Interval of the httpDownloadProbability check (in milliseconds).\n     */\n    httpDownloadProbabilityInterval: number;\n\n    /**\n     * Don't download segments over HTTP randomly when there is no peers.\n     */\n    httpDownloadProbabilitySkipIfNoPeers: boolean;\n\n    /**\n     * Timeout before trying to load segment again via HTTP after failed attempt (in milliseconds).\n     */\n    httpFailedSegmentTimeout: number;\n\n    /**\n     * Segments with higher priority will not be downloaded over HTTP.\n     */\n    httpDownloadMaxPriority: number;\n\n    /**\n     * Try to download initial segments over P2P if the value is > 0.\n     * But HTTP download will be forcibly enabled if there is no peers on tracker or\n     * single sequential segment P2P download is timed out (see httpDownloadInitialTimeoutPerSegment).\n     */\n    httpDownloadInitialTimeout: number;\n\n    /**\n     * Use HTTP ranges requests where it is possible.\n     * Allows to continue (and not start over) aborted P2P downloads over HTTP.\n     */\n    httpUseRanges: boolean;\n\n    /**\n     * If initial HTTP download timeout is enabled (see httpDownloadInitialTimeout)\n     * this parameter sets additional timeout for a single sequential segment download\n     * over P2P. It will cancel initial HTTP download timeout mode if a segment download is timed out.\n     */\n    httpDownloadInitialTimeoutPerSegment: number;\n\n    /**\n     * Max number of simultaneous downloads from peers.\n     */\n    simultaneousP2PDownloads: number;\n\n    /**\n     * Segments with higher priority will not be downloaded over P2P.\n     */\n    p2pDownloadMaxPriority: number;\n\n    /**\n     * Timeout to download a segment from a peer. If exceeded the peer is dropped.\n     */\n    p2pSegmentDownloadTimeout: number;\n\n    /**\n     * Max WebRTC message size. 64KiB - 1B should work with most of recent browsers. Set it to 16KiB for older browsers support.\n     */\n    webRtcMaxMessageSize: number;\n\n    /**\n     * Torrent trackers (announcers) to use.\n     */\n    trackerAnnounce: string[];\n\n    /**\n     * Number of requested peers in each announce for each tracker. Maximum is 10.\n     */\n    peerRequestsPerAnnounce: number;\n\n    /**\n     * An RTCConfiguration dictionary providing options to configure WebRTC connections.\n     */\n    rtcConfig: RTCConfiguration;\n\n    /**\n     * Segment validation callback - validates the data after it has been downloaded.\n     */\n    segmentValidator?: SegmentValidatorCallback;\n\n    /**\n     * XMLHttpRequest setup callback. Handle it when you need additional setup for requests made by the library.\n     */\n    /* xhrSetup?: unknown; */\n\n    /**\n     * Allow to modify the segment URL before HTTP request.\n     */\n    segmentUrlBuilder?: SegmentUrlBuilder;\n\n    /**\n     * A storage for the downloaded segments.\n     * By default the segments are stored in JavaScript memory.\n     */\n    segmentsStorage?: SegmentsStorage;\n};\n","import { LoaderContext } from \"hls.js\"\n\nexport type ByteRange = { length: number; offset: number } | undefined;\n\nexport function getByteRange(context: LoaderContext): { offset: number, length: number } | undefined {\n  return context.rangeEnd && context.rangeStart !== undefined\n      ? { offset: context.rangeStart, length: context.rangeEnd - context.rangeStart }\n      : undefined;\n}\n\nexport function compareByteRanges(b1: ByteRange, b2: ByteRange): boolean {\n  return b1 === undefined ? b2 === undefined : b2 !== undefined && b1.length === b2.length && b1.offset === b2.offset;\n}\n\nexport function byteRangeToString(byteRange: ByteRange): string | undefined {\n  if (byteRange === undefined) {\n      return undefined;\n  }\n\n  const end = byteRange.offset + byteRange.length - 1;\n\n  return `bytes=${byteRange.offset}-${end}`;\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Events, Segment, LoaderInterface } from \"../../p2p-media-loader-core/lib\";\nimport { Manifest, Parser } from \"m3u8-parser\";\nimport { ByteRange, byteRangeToString, compareByteRanges } from \"./byte-range\"\nimport { AssetsStorage, HlsJsEngineSettings } from \"./engine\";\n\nconst defaultSettings: SegmentManagerSettings = {\n    forwardSegmentCount: 20,\n    swarmId: undefined,\n    assetsStorage: undefined,\n};\n\nexport class SegmentManager {\n    public readonly loader: LoaderInterface;\n    private masterPlaylist: Playlist | null = null;\n    private readonly variantPlaylists = new Map<string, Playlist>();\n    private segmentRequest: SegmentRequest | null = null;\n    private readonly fetch: typeof fetch = (...args) => fetch(...args);\n    private playQueue: {\n        segmentSequence: number;\n        segmentUrl: string;\n        segmentByteRange: ByteRange;\n        playPosition?: {\n            start: number;\n            duration: number;\n        };\n    }[] = [];\n    private readonly settings: SegmentManagerSettings;\n\n    public constructor(loader: LoaderInterface, settings: Partial<HlsJsEngineSettings> = {}) {\n        this.settings = { ...defaultSettings, ...settings.segments };\n\n        this.loader = loader;\n        this.loader.on(Events.SegmentLoaded, this.onSegmentLoaded);\n        this.loader.on(Events.SegmentError, this.onSegmentError);\n        this.loader.on(Events.SegmentAbort, this.onSegmentAbort);\n\n        if (settings.loader && settings.loader.localTransport) {\n            this.fetch = settings.loader.localTransport;\n        }\n    }\n\n    public getSettings(): SegmentManagerSettings {\n        return this.settings;\n    }\n\n    public processPlaylist(requestUrl: string, content: string, responseUrl: string): void {\n        const parser = new Parser();\n        parser.push(content);\n        parser.end();\n\n        const playlist = new Playlist(requestUrl, responseUrl, parser.manifest);\n\n        if (playlist.manifest.playlists) {\n            this.masterPlaylist = playlist;\n\n            for (const [key, variantPlaylist] of this.variantPlaylists) {\n                const { streamSwarmId, found, index } = this.getStreamSwarmId(variantPlaylist.requestUrl);\n                if (!found) {\n                    this.variantPlaylists.delete(key);\n                } else {\n                    variantPlaylist.streamSwarmId = streamSwarmId;\n                    variantPlaylist.streamId = \"V\" + index.toString();\n                }\n            }\n        } else {\n            const { streamSwarmId, found, index } = this.getStreamSwarmId(requestUrl);\n\n            if (found || this.masterPlaylist === null) {\n                // do not add audio and subtitles to variants\n                playlist.streamSwarmId = streamSwarmId;\n                playlist.streamId = this.masterPlaylist === null ? undefined : \"V\" + index.toString();\n                this.variantPlaylists.set(requestUrl, playlist);\n                this.updateSegments();\n            }\n        }\n    }\n\n    public async loadPlaylist(url: string): Promise<{ response: string; responseURL: string }> {\n        const assetsStorage = this.settings.assetsStorage;\n        let res: { response: string; responseURL: string } | undefined;\n\n        if (assetsStorage !== undefined) {\n            let masterSwarmId: string | undefined;\n            masterSwarmId = this.getMasterSwarmId();\n            if (masterSwarmId === undefined) {\n                masterSwarmId = url.split(\"?\")[0];\n            }\n            const asset = await assetsStorage.getAsset(url, undefined, masterSwarmId);\n\n            if (asset !== undefined) {\n                res = {\n                    responseURL: asset.responseUri,\n                    response: asset.data as string,\n                };\n            } else {\n                const fetch = await this.loadContent(url);\n\n                res = {\n                    responseURL: fetch.url,\n                    response: await fetch.text(),\n                };\n\n                void assetsStorage.storeAsset({\n                    masterManifestUri: this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : url,\n                    masterSwarmId: masterSwarmId,\n                    requestUri: url,\n                    responseUri: res.responseURL,\n                    data: await res.response,\n                });\n            }\n        } else {\n            const fetch = await this.loadContent(url);\n\n            res = {\n                responseURL: fetch.url,\n                response: await fetch.text(),\n            };\n        }\n\n        this.processPlaylist(url, res.response, res.responseURL);\n        return res;\n    }\n\n    \n\n    public async loadSegment(\n        url: string,\n        byteRange: ByteRange\n    ): Promise<{ content: ArrayBuffer | undefined; downloadBandwidth?: number }> {\n        const segmentLocation = this.getSegmentLocation(url, byteRange);\n        const byteRangeString = byteRangeToString(byteRange);\n\n        if (!segmentLocation) {\n            let content: ArrayBuffer | undefined;\n\n            // Not a segment from variants; usually can be: init, audio or subtitles segment, encryption key etc.\n            const assetsStorage = this.settings.assetsStorage;\n            if (assetsStorage !== undefined) {\n                let masterManifestUri = this.masterPlaylist?.requestUrl;\n\n                let masterSwarmId: string | undefined;\n                masterSwarmId = this.getMasterSwarmId();\n\n                if (masterSwarmId === undefined && this.variantPlaylists.size === 1) {\n                    const result = this.variantPlaylists.values().next();\n                    if (!result.done) {\n                        // always true\n                        masterSwarmId = result.value.requestUrl.split(\"?\")[0];\n                    }\n                }\n\n                if (masterManifestUri === undefined && this.variantPlaylists.size === 1) {\n                    const result = this.variantPlaylists.values().next();\n                    if (!result.done) {\n                        // always true\n                        masterManifestUri = result.value.requestUrl;\n                    }\n                }\n\n                if (masterSwarmId !== undefined && masterManifestUri !== undefined) {\n                    const asset = await assetsStorage.getAsset(url, byteRangeString, masterSwarmId);\n                    if (asset !== undefined) {\n                        content = asset.data as ArrayBuffer;\n                    } else {\n                        const fetch = await this.loadContent(url, byteRangeString);\n                        content = await fetch.arrayBuffer();\n                        void assetsStorage.storeAsset({\n                            masterManifestUri: masterManifestUri,\n                            masterSwarmId: masterSwarmId,\n                            requestUri: url,\n                            requestRange: byteRangeString,\n                            responseUri: fetch.url,\n                            data: content,\n                        });\n                    }\n                }\n            }\n\n            if (content === undefined) {\n                const fetch = await this.loadContent(url, byteRangeString);\n                content = await fetch.arrayBuffer();\n            }\n\n            return { content, downloadBandwidth: 0 };\n        }\n\n        const segmentSequence =\n            (segmentLocation.playlist.manifest.mediaSequence ? segmentLocation.playlist.manifest.mediaSequence : 0) +\n            segmentLocation.segmentIndex;\n\n        if (this.playQueue.length > 0) {\n            const previousSegment = this.playQueue[this.playQueue.length - 1];\n            if (previousSegment.segmentSequence !== segmentSequence - 1) {\n                // Reset play queue in case of segment loading out of sequence\n                this.playQueue = [];\n            }\n        }\n\n        if (this.segmentRequest) {\n            this.segmentRequest.onError(\"Cancel segment request: simultaneous segment requests are not supported\");\n        }\n\n        const promise = new Promise<{ content: ArrayBuffer | undefined; downloadBandwidth?: number }>(\n            (resolve, reject) => {\n\n                this.segmentRequest = new SegmentRequest(\n                    url,\n                    byteRange,\n                    segmentSequence,\n                    segmentLocation.playlist.requestUrl,\n                    (content: ArrayBuffer | undefined, downloadBandwidth?: number) =>\n                        resolve({ content, downloadBandwidth }),\n                    (error) => reject(error)\n                );\n                \n            }\n        );\n\n        this.playQueue.push({ segmentUrl: url, segmentByteRange: byteRange, segmentSequence: segmentSequence });\n        void this.loadSegments(segmentLocation.playlist, segmentLocation.segmentIndex, true);\n\n        return promise;\n    }\n\n    public setPlayingSegment(url: string, byteRange: ByteRange, start: number, duration: number): void {\n        const urlIndex = this.playQueue.findIndex(\n            (segment) => segment.segmentUrl === url && compareByteRanges(segment.segmentByteRange, byteRange)\n        );\n\n        if (urlIndex >= 0) {\n            this.playQueue = this.playQueue.slice(urlIndex);\n            this.playQueue[0].playPosition = { start, duration };\n            this.updateSegments();\n        }\n    }\n\n    public setPlayingSegmentByCurrentTime(playheadPosition: number): void {\n        if (this.playQueue.length === 0 || !this.playQueue[0].playPosition) {\n            return;\n        }\n\n        const currentSegmentPosition = this.playQueue[0].playPosition;\n        const segmentEndTime = currentSegmentPosition.start + currentSegmentPosition.duration;\n\n        if (segmentEndTime - playheadPosition < 0.2) {\n            // means that current segment is (almost) finished playing\n            // remove it from queue\n\n            this.playQueue = this.playQueue.slice(1);\n            this.updateSegments();\n        }\n    }\n\n    public abortSegment(url: string, byteRange: ByteRange): void {\n        if (\n            this.segmentRequest &&\n            this.segmentRequest.segmentUrl === url &&\n            compareByteRanges(this.segmentRequest.segmentByteRange, byteRange)\n        ) {\n            this.segmentRequest.onSuccess(undefined, 0);\n            this.segmentRequest = null;\n        }\n    }\n\n    public async destroy(): Promise<void> {\n        if (this.segmentRequest) {\n            this.segmentRequest.onError(\"Loading aborted: object destroyed\");\n            this.segmentRequest = null;\n        }\n\n        this.masterPlaylist = null;\n        this.variantPlaylists.clear();\n        this.playQueue = [];\n\n        if (this.settings.assetsStorage !== undefined) {\n            await this.settings.assetsStorage.destroy();\n        }\n\n        await this.loader.destroy();\n    }\n\n    private updateSegments(): void {\n        if (!this.segmentRequest) {\n            return;\n        }\n\n        const segmentLocation = this.getSegmentLocation(\n            this.segmentRequest.segmentUrl,\n            this.segmentRequest.segmentByteRange\n        );\n        if (segmentLocation) {\n            void this.loadSegments(segmentLocation.playlist, segmentLocation.segmentIndex, false);\n        }\n    }\n\n    private onSegmentLoaded = (segment: Segment) => {\n        if (\n            this.segmentRequest &&\n            this.segmentRequest.segmentUrl === segment.url &&\n            byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range\n        ) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.segmentRequest.onSuccess(segment.data!.slice(0), segment.downloadBandwidth);\n            this.segmentRequest = null;\n        }\n    };\n\n    private onSegmentError = (segment: Segment, error: unknown) => {\n        if (\n            this.segmentRequest &&\n            this.segmentRequest.segmentUrl === segment.url &&\n            byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range\n        ) {\n            this.segmentRequest.onError(error);\n            this.segmentRequest = null;\n        }\n    };\n\n    private onSegmentAbort = (segment: Segment) => {\n        if (\n            this.segmentRequest &&\n            this.segmentRequest.segmentUrl === segment.url &&\n            byteRangeToString(this.segmentRequest.segmentByteRange) === segment.range\n        ) {\n            this.segmentRequest.onError(\"Loading aborted: internal abort\");\n            this.segmentRequest = null;\n        }\n    };\n\n    private getSegmentLocation(\n        url: string,\n        byteRange: ByteRange\n    ): { playlist: Playlist; segmentIndex: number } | undefined {\n        for (const playlist of this.variantPlaylists.values()) {\n            const segmentIndex = playlist.getSegmentIndex(url, byteRange);\n            if (segmentIndex >= 0) {\n                return { playlist: playlist, segmentIndex: segmentIndex };\n            }\n        }\n\n        return undefined;\n    }\n\n    private async loadSegments(playlist: Playlist, segmentIndex: number, requestFirstSegment: boolean) {\n        const segments: Segment[] = [];\n        const playlistSegments = playlist.manifest.segments;\n        const initialSequence = playlist.manifest.mediaSequence ?? 0;\n        let loadSegmentId: string | null = null;\n\n        let priority = Math.max(0, this.playQueue.length - 1);\n\n        const masterSwarmId = this.getMasterSwarmId();\n\n        for (\n            let i = segmentIndex;\n            i < playlistSegments.length && segments.length < this.settings.forwardSegmentCount;\n            ++i\n        ) {\n            const segment = playlist.manifest.segments[i];\n\n            const url = playlist.getSegmentAbsoluteUrl(segment.uri);\n            const byteRange: ByteRange = segment.byterange;\n            const id = this.getSegmentId(playlist, initialSequence + i);\n\n            segments.push({\n                id: id,\n                url: url,\n                masterSwarmId: masterSwarmId !== undefined ? masterSwarmId : playlist.streamSwarmId,\n                masterManifestUri: this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : playlist.requestUrl,\n                streamId: playlist.streamId,\n                sequence: (initialSequence + i).toString(),\n                range: byteRangeToString(byteRange),\n                priority: priority++,\n            });\n            if (requestFirstSegment && !loadSegmentId) {\n                loadSegmentId = id;\n            }\n        }\n\n        this.loader.load(segments, playlist.streamSwarmId);\n\n        if (loadSegmentId) {\n            const segment = await this.loader.getSegment(loadSegmentId);\n\n\n\n            if (segment) {\n                // Segment already loaded by loader\n                this.onSegmentLoaded(segment);\n            }\n        }\n    }\n\n    private getSegmentId(playlist: Playlist, segmentSequence: number): string {\n        return `${playlist.streamSwarmId}+${segmentSequence}`;\n    }\n\n    private getMasterSwarmId() {\n        const settingsSwarmId =\n            this.settings.swarmId && this.settings.swarmId.length !== 0 ? this.settings.swarmId : undefined;\n        if (settingsSwarmId !== undefined) {\n            return settingsSwarmId;\n        }\n\n        return this.masterPlaylist !== null ? this.masterPlaylist.requestUrl.split(\"?\")[0] : undefined;\n    }\n\n    private getStreamSwarmId(playlistUrl: string): { streamSwarmId: string; found: boolean; index: number } {\n        const masterSwarmId = this.getMasterSwarmId();\n\n        if (this.masterPlaylist && this.masterPlaylist.manifest.playlists && masterSwarmId) {\n            for (let i = 0; i < this.masterPlaylist.manifest.playlists.length; ++i) {\n                const url = new URL(\n                    this.masterPlaylist.manifest.playlists[i].uri,\n                    this.masterPlaylist.responseUrl\n                ).toString();\n                if (url === playlistUrl) {\n                    return { streamSwarmId: `${masterSwarmId}+V${i}`, found: true, index: i };\n                }\n            }\n        }\n\n        return {\n            streamSwarmId: masterSwarmId ?? playlistUrl.split(\"?\")[0],\n            found: false,\n            index: -1,\n        };\n    }\n\n    private async loadContent(\n        url: string,\n        range?: string\n    ): Promise<Response> {\n        const headers = new Headers();\n\n        if (range) {\n            headers.append('Range', range);\n        }\n\n        const fetchPromise = this.fetch(url, { headers });\n\n        fetchPromise.catch((err) => {\n            /**\n             * Handling all fetch errors here\n             */\n\n            // console.log(\"SegmentManager fetch error\", { err });\n        });\n\n        return fetchPromise;\n    }\n}\n\nclass Playlist {\n    public streamSwarmId = \"\";\n    public streamId?: string;\n\n    public constructor(readonly requestUrl: string, readonly responseUrl: string, readonly manifest: Manifest) {}\n\n    public getSegmentIndex(url: string, byteRange: ByteRange): number {\n        for (let i = 0; i < this.manifest.segments.length; ++i) {\n            const segment = this.manifest.segments[i];\n            const segmentUrl = this.getSegmentAbsoluteUrl(segment.uri);\n\n            if (url === segmentUrl && compareByteRanges(segment.byterange, byteRange)) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    public getSegmentAbsoluteUrl(segmentUrl: string): string {\n        return new URL(segmentUrl, this.responseUrl).toString();\n    }\n}\n\nclass SegmentRequest {\n    public constructor(\n        readonly segmentUrl: string,\n        readonly segmentByteRange: ByteRange,\n        readonly segmentSequence: number,\n        readonly playlistRequestUrl: string,\n        readonly onSuccess: (content: ArrayBuffer | undefined, downloadBandwidth: number | undefined) => void,\n        readonly onError: (error: unknown) => void\n    ) {}\n}\n\nexport interface SegmentManagerSettings {\n    /**\n     * Number of segments for building up predicted forward segments sequence; used to predownload and share via P2P\n     */\n    forwardSegmentCount: number;\n\n    /**\n     * Override default swarm ID that is used to identify unique media stream with trackers (manifest URL without\n     * query parameters is used as the swarm ID if the parameter is not specified)\n     */\n    swarmId?: string;\n\n    /**\n     * A storage for the downloaded assets: manifests, subtitles, init segments, DRM assets etc. By default the assets are not stored.\n     */\n    assetsStorage?: AssetsStorage;\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SegmentManager } from \"./segment-manager\";\nimport type { LoaderCallbacks, LoaderConfiguration, LoaderContext, LoaderStats } from \"hls.js\";\nimport { Events, Segment } from \"../../p2p-media-loader-core/lib\";\nimport { byteRangeToString, getByteRange } from \"./byte-range\"\n\nexport class HlsJsLoader {\n    private isLoaded = false;\n    private segmentManager: SegmentManager;\n    public stats: LoaderStats = {\n        loaded: 0,\n        total: 0,\n        aborted: false,\n        retry: 0,\n        chunkCount: 0,\n        bwEstimate: 0,\n        loading: {\n            start: 0,\n            end: 0,\n            first: 0,\n        },\n        parsing: {\n            start: 0,\n            end: 0,\n        },\n        buffering: {\n            start: 0,\n            end: 0,\n            first: 0,\n        },\n    };\n\n    public constructor(segmentManager: SegmentManager) {\n        this.segmentManager = segmentManager;\n    }\n\n    public async load(\n        context: LoaderContext,\n        _config: LoaderConfiguration,\n        callbacks: LoaderCallbacks<LoaderContext>\n    ): Promise<void> {\n        HlsJsLoader.updateStatsToStartLoading(this.stats)\n\n        if (((context as unknown) as { type: unknown }).type) {\n            try {\n                const result = await this.segmentManager.loadPlaylist(context.url);\n                this.isLoaded = true;\n                this.successPlaylist(result, context, callbacks);\n            } catch (e : any) {\n                this.error(e, context, callbacks);\n            }\n        } else if (((context as unknown) as { frag: unknown }).frag) {\n            const { loader } = this.segmentManager;\n            const byteRange = getByteRange(context)\n\n            const isSegment = (segment: Segment) => {\n                return segment.url === context.url && segment.range === byteRangeToString(byteRange)\n            }\n\n            // We may be downloading the segment by P2P, so we don't care about the stats sent to HLS ABR\n            let updateStart: NodeJS.Timeout | undefined = setInterval(() => {\n                HlsJsLoader.updateStatsToStartLoading(this.stats)\n            }, 200)\n\n            const onUpdateSegmentSize = (segment: Segment, size: number) => {\n                if (!isSegment(segment)) return\n\n                this.stats.total = size\n            };\n            loader.on(Events.SegmentSize, onUpdateSegmentSize)\n\n            const onUpdateLoaded = (_type: unknown, segment: Segment, bytes: number) => {\n                if (!isSegment(segment)) return\n\n                this.stats.loaded += bytes\n            };\n\n            const onSegmentStartLoad = (method: \"http\" | \"p2p\", segment: Segment) => {\n                if (!updateStart || method !== \"http\" || !isSegment(segment)) return\n\n                clearInterval(updateStart)\n                updateStart = undefined\n\n                HlsJsLoader.updateStatsToStartLoading(this.stats)\n\n                loader.on(Events.PieceBytesDownloaded, onUpdateLoaded)\n            };\n\n            loader.on(Events.SegmentStartLoad, onSegmentStartLoad)\n\n\n            try {\n                const result = await this.segmentManager.loadSegment(context.url, byteRange);\n                const { content } = result;\n                if (content) {\n                    this.isLoaded = true;\n                    setTimeout(() => this.successSegment(content, context, callbacks), 0);\n                }\n\n            } catch (e : any) {\n                setTimeout(() => this.error(e, context, callbacks), 0);\n            } finally {\n\n                clearInterval(updateStart)\n                loader.off(Events.SegmentStartLoad, onSegmentStartLoad)\n                loader.off(Events.SegmentSize, onUpdateSegmentSize)\n                loader.off(Events.PieceBytesDownloaded, onUpdateLoaded)\n            }\n\n\n\n\n        } else {\n            console.warn(\"Unknown load request\", context);\n        }\n    }\n\n    public abort(context: LoaderContext, callbacks?: LoaderCallbacks<LoaderContext>): void {\n        if (this.isLoaded) return;\n\n        this.segmentManager.abortSegment(context.url, getByteRange(context));\n        this.stats.aborted = true;\n\n        const onAbort = callbacks?.onAbort;\n        if (onAbort) {\n            onAbort(this.stats, context, undefined);\n        }\n    }\n\n    private successPlaylist(\n        xhr: { response: string; responseURL: string },\n        context: LoaderContext,\n        callbacks: LoaderCallbacks<LoaderContext>\n    ): void {\n        const now = performance.now();\n\n        this.stats.loading.end = now;\n        this.stats.loaded = xhr.response.length;\n        this.stats.total = xhr.response.length;\n\n        callbacks.onSuccess(\n            {\n                url: xhr.responseURL,\n                data: xhr.response,\n            },\n            this.stats,\n            context,\n            undefined\n        );\n    }\n\n    private successSegment(\n        content: ArrayBuffer,\n        context: LoaderContext,\n        callbacks: LoaderCallbacks<LoaderContext>\n    ): void {\n        const now = performance.now();\n\n        this.stats.loading.end = now;\n        this.stats.loaded = content.byteLength;\n        this.stats.total = content.byteLength;\n\n        if (callbacks.onProgress) {\n            callbacks.onProgress(this.stats, context, content, undefined);\n        }\n\n        callbacks.onSuccess(\n            {\n                url: context.url,\n                data: content,\n            },\n            this.stats,\n            context,\n            undefined\n        );\n    }\n\n    private error(\n        error: { code: number; text: string },\n        context: LoaderContext,\n        callbacks: LoaderCallbacks<LoaderContext>\n    ): void {\n        callbacks.onError(error, context, undefined);\n    }\n\n    private static updateStatsToStartLoading (stats: LoaderStats) {\n        const start = performance.now();\n        stats.loading.start = start;\n        stats.loading.first = start;\n    }\n}\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { EventEmitter } from \"events\";\nimport { Events, LoaderInterface, HybridLoader, HybridLoaderSettings } from \"../../p2p-media-loader-core/lib\";\nimport { SegmentManager, SegmentManagerSettings } from \"./segment-manager\";\nimport { HlsJsLoader } from \"./hlsjs-loader\";\nimport type { LoaderCallbacks, LoaderConfiguration, LoaderContext, LoaderStats } from \"hls.js\";\nimport { ByteRange } from \"./byte-range\"\n\nexport interface HlsJsEngineSettings {\n    loader: Partial<HybridLoaderSettings & { localTransport?: typeof fetch }>;\n    segments: Partial<SegmentManagerSettings>;\n}\n\nexport class Engine extends EventEmitter {\n    public static isSupported(): boolean {\n        return HybridLoader.isSupported();\n    }\n\n    private readonly loader: LoaderInterface;\n    private readonly segmentManager: SegmentManager;\n\n    public constructor(settings: Partial<HlsJsEngineSettings> = {}) {\n        super();\n\n        this.loader = new HybridLoader(settings.loader);\n        this.segmentManager = new SegmentManager(this.loader, settings);\n\n        Object.keys(Events)\n            .map((eventKey) => Events[eventKey as keyof typeof Events])\n            .forEach((event) => this.loader.on(event, (...args: unknown[]) => this.emit(event, ...args)));\n    }\n\n    public createLoaderClass(): new () => unknown {\n        const engine = this; // eslint-disable-line @typescript-eslint/no-this-alias\n        return class {\n            private impl: HlsJsLoader;\n            private context?: LoaderContext;\n            private callbacks?: LoaderCallbacks<LoaderContext>;\n            public stats: LoaderStats;\n\n            constructor() {\n                this.impl = new HlsJsLoader(engine.segmentManager);\n                this.stats = this.impl.stats;\n            }\n\n            load = async (\n                context: LoaderContext,\n                config: LoaderConfiguration,\n                callbacks: LoaderCallbacks<LoaderContext>\n            ) => {\n                this.context = context;\n                this.callbacks = callbacks;\n                this.impl.load(context, config, callbacks);\n\n            };\n\n            abort = () => {\n                if (this.context) {\n                    this.impl.abort(this.context, this.callbacks);\n                }\n            };\n\n            destroy = () => {\n                if (this.context) {\n                    this.impl.abort(this.context);\n                }\n            };\n\n            getResponseHeader = () => undefined;\n\n            static getEngine = () => {\n                return engine;\n            };\n        };\n    }\n\n    public async destroy(): Promise<void> {\n        await this.segmentManager.destroy();\n    }\n\n    public getSettings(): {\n        segments: SegmentManagerSettings;\n        loader: unknown;\n    } {\n        return {\n            segments: this.segmentManager.getSettings(),\n            loader: this.loader.getSettings(),\n        };\n    }\n\n    public getDetails(): unknown {\n        return {\n            loader: this.loader.getDetails(),\n        };\n    }\n\n    public setPlayingSegment(url: string, byteRange: ByteRange, start: number, duration: number): void {\n        this.segmentManager.setPlayingSegment(url, byteRange, start, duration);\n    }\n\n    public setPlayingSegmentByCurrentTime(playheadPosition: number): void {\n        this.segmentManager.setPlayingSegmentByCurrentTime(playheadPosition);\n    }\n\n}\n\nexport interface Asset {\n    masterSwarmId: string;\n    masterManifestUri: string;\n    requestUri: string;\n    requestRange?: string;\n    responseUri: string;\n    data: ArrayBuffer | string;\n}\n\nexport interface AssetsStorage {\n    storeAsset(asset: Asset): Promise<void>;\n    getAsset(requestUri: string, requestRange: string | undefined, masterSwarmId: string): Promise<Asset | undefined>;\n    destroy(): Promise<void>;\n}\n","/**\n * @license Apache-2.0\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable */\n\nexport const version = \"0.6.2\";\nexport * from \"./engine\";\nexport * from \"./segment-manager\";\n\nimport { Engine } from \"./engine\";\n\ndeclare const videojs: any;\n\ndeclare global {\n    interface Window {\n        p2pml: Record<string, unknown>;\n    }\n}\n\nexport function initHlsJsPlayer(player: any): void {\n    if (player && player.config && player.config.loader && typeof player.config.loader.getEngine === \"function\") {\n        initHlsJsEvents(player, player.config.loader.getEngine());\n    }\n}\n\nexport function initClapprPlayer(player: any): void {\n    player.on(\"play\", () => {\n        const playback = player.core.getCurrentPlayback();\n        if (playback._hls && !playback._hls._p2pm_linitialized) {\n            playback._hls._p2pm_linitialized = true;\n            initHlsJsPlayer(player.core.getCurrentPlayback()._hls);\n        }\n    });\n}\n\nexport function initFlowplayerHlsJsPlayer(player: any): void {\n    player.on(\"ready\", () => initHlsJsPlayer(player.engine.hlsjs ?? player.engine.hls));\n}\n\nexport function initVideoJsContribHlsJsPlayer(player: any): void {\n    player.ready(() => {\n        const options = player.tech_.options_;\n        if (\n            options &&\n            options.hlsjsConfig &&\n            options.hlsjsConfig.loader &&\n            typeof options.hlsjsConfig.loader.getEngine === \"function\"\n        ) {\n            initHlsJsEvents(player.tech_, options.hlsjsConfig.loader.getEngine());\n        }\n    });\n}\n\nexport function initVideoJsHlsJsPlugin(): void {\n    if (videojs == undefined || videojs.Html5Hlsjs == undefined) {\n        return;\n    }\n\n    videojs.Html5Hlsjs.addHook(\"beforeinitialize\", (videojsPlayer: any, hlsjs: any) => {\n        if (hlsjs.config && hlsjs.config.loader && typeof hlsjs.config.loader.getEngine === \"function\") {\n            initHlsJsEvents(hlsjs, hlsjs.config.loader.getEngine());\n        }\n    });\n}\n\nexport function initMediaElementJsPlayer(mediaElement: any): void {\n\n\n    mediaElement.addEventListener(\"hlsFragChanged\", (event: any) => {\n        const hls = mediaElement.hlsPlayer;\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\n            const engine: Engine = hls.config.loader.getEngine();\n\n            if (event.data && event.data.length > 1) {\n                const frag = event.data[1].frag;\n                const byteRange =\n                    frag.byteRange.length !== 2\n                        ? undefined\n                        : { offset: frag.byteRange[0], length: frag.byteRange[1] - frag.byteRange[0] };\n                engine.setPlayingSegment(frag.url, byteRange, frag.start, frag.duration);\n            }\n        }\n    });\n    mediaElement.addEventListener(\"hlsDestroying\", async () => {\n        const hls = mediaElement.hlsPlayer;\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\n            const engine: Engine = hls.config.loader.getEngine();\n            await engine.destroy();\n        }\n    });\n    mediaElement.addEventListener(\"hlsError\", (event: any) => {\n        const hls = mediaElement.hlsPlayer;\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\n            if (event.data !== undefined && event.data.details === \"bufferStalledError\") {\n                const engine: Engine = hls.config.loader.getEngine();\n                engine.setPlayingSegmentByCurrentTime(hls.media.currentTime);\n            }\n        }\n    });\n}\n\nexport function initJwPlayer(player: any, hlsjsConfig: any): void {\n    const iid = setInterval(() => {\n        if (player.hls && player.hls.config) {\n            clearInterval(iid);\n            Object.assign(player.hls.config, hlsjsConfig);\n            initHlsJsPlayer(player.hls);\n        }\n    }, 200);\n}\n\nfunction initHlsJsEvents(player: any, engine: Engine): void {\n    player.on(\"hlsFragChanged\", (_event: string, data: any) => {\n        const frag = data.frag;\n        const byteRange =\n            frag.byteRange.length !== 2\n                ? undefined\n                : { offset: frag.byteRange[0], length: frag.byteRange[1] - frag.byteRange[0] };\n        engine.setPlayingSegment(frag.url, byteRange, frag.start, frag.duration);\n    });\n    player.on(\"hlsDestroying\", async () => {\n        await engine.destroy();\n    });\n    player.on(\"hlsError\", (_event: string, errorData: { details: string }) => {\n        if (errorData.details === \"bufferStalledError\") {\n            const htmlMediaElement = (player.media === undefined\n                ? player.el_ // videojs-contrib-hlsjs\n                : player.media) as HTMLMediaElement | undefined; // all others\n            if (htmlMediaElement) {\n                engine.setPlayingSegmentByCurrentTime(htmlMediaElement.currentTime);\n            }\n        }\n    });\n}\n"],"sourceRoot":""}